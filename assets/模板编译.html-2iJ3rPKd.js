import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as r,e as a,o}from"./app-D4yN_ylH.js";const n={};function l(s,e){return o(),r("div",null,e[0]||(e[0]=[a(`<p>下面文章从 <strong>模板编译优化</strong> 的几个核心维度入手，结合多篇实战与源码解析，全面介绍 Vue 3 如何通过静态分析与编译时标记，减少运行时成本、加速虚拟 DOM 渲染。</p><p>Vue 3 的模板编译优化主要体现在以下几点：</p><ul><li><strong>静态提升（Static Hoisting）</strong>：将真正不变的节点提取到渲染函数外层，避免每次重新创建 (<a href="https://www.cnblogs.com/heavenYJJ/p/18190230?utm_source=chatgpt.com" target="_blank" rel="noopener noreferrer">vue3编译优化之“静态提升” - 前端欧阳- 博客园</a>)。</li><li><strong>Patch Flag &amp; Block Tree</strong>：编译器为动态节点打上精细的“更新标记”，并用 Block Tree+dynamicChildren 列出真正需更新的子树，跳过大部分比对 (<a href="https://blog.csdn.net/weixin_40297452/article/details/121143356?utm_source=chatgpt.com" target="_blank" rel="noopener noreferrer">vue3.0性能优化点之静态标记(PatchFlag) 原创 - CSDN博客</a>, <a href="https://open.alipay.com/portal/forum/post/108301027?utm_source=chatgpt.com" target="_blank" rel="noopener noreferrer">从面试题入手，畅谈Vue 3 性能优化-支付宝开发者社区</a>)。</li><li><strong>事件与属性绑定优化</strong>：对动态 class、style、props 和事件处理函数生成最小化的更新逻辑，复用相同回调并减少开销 (<a href="https://zhuanlan.zhihu.com/p/150732926?utm_source=chatgpt.com" target="_blank" rel="noopener noreferrer">Vue3 Compiler 优化细节，如何手写高性能渲染函数 - 知乎专栏</a>, <a href="https://vuejs.org/guide/extras/rendering-mechanism?utm_source=chatgpt.com" target="_blank" rel="noopener noreferrer">Rendering Mechanism - Vue.js</a>)。</li><li><strong>指令与插槽编译</strong>：对内置指令（如 v-for、v-if）和插槽做特殊代码生成，提前计算分支与缓存结果 (<a href="https://zhuanlan.zhihu.com/p/181505806?utm_source=chatgpt.com" target="_blank" rel="noopener noreferrer">Vue3 模板编译原理 - 知乎专栏</a>, <a href="https://vuejs.org/api/built-in-directives.html?utm_source=chatgpt.com" target="_blank" rel="noopener noreferrer">Built-in Directives | Vue.js</a>)。</li></ul><hr><h2 id="📝-模板编译概览" tabindex="-1"><a class="header-anchor" href="#📝-模板编译概览"><span>📝 模板编译概览</span></a></h2><p>Vue 3 在编译阶段通过 AST 分析模板，将 <code>template</code> 转换成高效的渲染函数（<code>render</code>），并在过程中收集各种静态和动态信息：</p><ol><li><strong>静态节点检测</strong>：判断哪些元素或文本不会随状态改变 (<a href="https://originalix.github.io/2021/05/10/Vue3%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%28%E4%B8%89%29-%E9%9D%99%E6%80%81%E6%8F%90%E5%8D%87/?utm_source=chatgpt.com" target="_blank" rel="noopener noreferrer">Vue3 源码解析（三）：静态提升 - 李晓的博客</a>)。</li><li><strong>Patch Flag 标记</strong>：为动态属性和子节点类型添加枚举值来指示更新策略 (<a href="https://github.com/vuejs/core/blob/main/packages/shared/src/patchFlags.ts?utm_source=chatgpt.com" target="_blank" rel="noopener noreferrer">core/packages/shared/src/patchFlags.ts at main · vuejs/core - GitHub</a>)。</li><li><strong>Block Tree 分块</strong>：将整个 VNode 树拆分为“静态块”与“动态块”，动态块内部再用 <code>dynamicChildren</code> 数组存放最小更新单元 (<a href="https://juejin.cn/post/7084597196359745573?utm_source=chatgpt.com" target="_blank" rel="noopener noreferrer">vue3的改变（hoist 与Block） - 稀土掘金</a>)。</li></ol><p>这样一次编译就把“哪些内容会变”“怎么变”都预先算好了，运行时只做必要的比对和更新，大大提升渲染速度 (<a href="https://juejin.cn/post/7247324653840367675?utm_source=chatgpt.com" target="_blank" rel="noopener noreferrer">Vue3系列三：模版编译及优化的源码解析 - 稀土掘金</a>)。</p><hr><h2 id="🚀-静态提升-static-hoisting" tabindex="-1"><a class="header-anchor" href="#🚀-静态提升-static-hoisting"><span>🚀 静态提升（Static Hoisting）</span></a></h2><h3 id="原理与目的" tabindex="-1"><a class="header-anchor" href="#原理与目的"><span>原理与目的</span></a></h3><ul><li><strong>原理</strong>：将 AST 中可完全确定为常量的节点（包括属性、文本、样式对象）在编译时抽取成顶层变量，渲染函数执行时直接引用，不再每次重建 VNode (<a href="https://www.cnblogs.com/heavenYJJ/p/18190230?utm_source=chatgpt.com" target="_blank" rel="noopener noreferrer">vue3编译优化之“静态提升” - 前端欧阳- 博客园</a>)。</li><li><strong>目的</strong>：避免重复创建相同的 VNode 对象，减少垃圾回收和内存分配成本。</li></ul><h3 id="源码实现" tabindex="-1"><a class="header-anchor" href="#源码实现"><span>源码实现</span></a></h3><ul><li>在 <code>optimize</code> 阶段为静态节点打上 <code>HOISTED</code> 标记（<code>PatchFlags.HOISTED</code>）并收集到 <code>ast.hoists</code> 数组中 (<a href="https://originalix.github.io/2021/05/10/Vue3%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%28%E4%B8%89%29-%E9%9D%99%E6%80%81%E6%8F%90%E5%8D%87/?utm_source=chatgpt.com" target="_blank" rel="noopener noreferrer">Vue3 源码解析（三）：静态提升 - 李晓的博客</a>)。</li><li>在 <code>codegen</code> 阶段调用 <code>genHoists(ast.hoists, context)</code> 生成诸如 <code>_hoisted_1 = createElementVNode(&#39;div&#39;, ... )</code> 的顶层常量声明。</li></ul><hr><h2 id="🎯-patch-flag-与-block-tree" tabindex="-1"><a class="header-anchor" href="#🎯-patch-flag-与-block-tree"><span>🎯 Patch Flag 与 Block Tree</span></a></h2><h3 id="patch-flag-精细标记" tabindex="-1"><a class="header-anchor" href="#patch-flag-精细标记"><span>Patch Flag 精细标记</span></a></h3><ul><li><strong>PatchFlags 枚举</strong>：包含 <code>TEXT</code>、<code>CLASS</code>、<code>STYLE</code>、<code>PROPS</code>、<code>FULL_PROPS</code>、<code>STABLE_FRAGMENT</code> 等标识 (<a href="https://blog.csdn.net/weixin_40297452/article/details/121143356?utm_source=chatgpt.com" target="_blank" rel="noopener noreferrer">vue3.0性能优化点之静态标记(PatchFlag) 原创 - CSDN博客</a>, <a href="https://github.com/vuejs/core/blob/main/packages/shared/src/patchFlags.ts?utm_source=chatgpt.com" target="_blank" rel="noopener noreferrer">core/packages/shared/src/patchFlags.ts at main · vuejs/core - GitHub</a>)。</li><li><strong>作用</strong>：运行时 <code>patchElement</code> 检测 <code>vnode.patchFlag</code>，只更新对应部分，如：<div class="language-js line-numbers-mode" data-highlighter="shiki" data-ext="js" data-title="js" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">if</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">vnode</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">patchFlag</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> &amp;</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> PatchFlags</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#986801;--shiki-dark:#E06C75;">CLASS</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // 仅更新 class</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>(<a href="https://vuejs.org/guide/extras/rendering-mechanism?utm_source=chatgpt.com" target="_blank" rel="noopener noreferrer">Rendering Mechanism - Vue.js</a>)</li></ul><h3 id="block-tree-dynamicchildren" tabindex="-1"><a class="header-anchor" href="#block-tree-dynamicchildren"><span>Block Tree + dynamicChildren</span></a></h3><ul><li><strong>Block Tree</strong>：在渲染函数中用 <code>_openBlock()</code> / <code>_createElementBlock()</code> 生成一个带有 <code>dynamicChildren</code> 数组的根节点块 (<a href="https://vuejs.org/guide/extras/rendering-mechanism?utm_source=chatgpt.com" target="_blank" rel="noopener noreferrer">Rendering Mechanism - Vue.js</a>)。</li><li><strong>dynamicChildren</strong>：仅存放该块内打了 Patch Flag 的子节点，diff 时只遍历这里，不再走全树递归 (<a href="https://open.alipay.com/portal/forum/post/108301027?utm_source=chatgpt.com" target="_blank" rel="noopener noreferrer">从面试题入手，畅谈Vue 3 性能优化-支付宝开发者社区</a>)。</li></ul><hr><h2 id="🔄-事件与绑定优化" tabindex="-1"><a class="header-anchor" href="#🔄-事件与绑定优化"><span>🔄 事件与绑定优化</span></a></h2><h3 id="复用事件处理函数" tabindex="-1"><a class="header-anchor" href="#复用事件处理函数"><span>复用事件处理函数</span></a></h3><ul><li>编译器对同一处理函数做缓存：当检测到 <code>onClick=&quot;doSomething&quot;</code> 相同字符串时，复用同一个函数引用，避免在每次渲染时重新生成匿名函数 (<a href="https://zhuanlan.zhihu.com/p/150732926?utm_source=chatgpt.com" target="_blank" rel="noopener noreferrer">Vue3 Compiler 优化细节，如何手写高性能渲染函数 - 知乎专栏</a>)。</li></ul><h3 id="动态属性快速路径" tabindex="-1"><a class="header-anchor" href="#动态属性快速路径"><span>动态属性快速路径</span></a></h3><ul><li>对 <code>:class</code>、<code>:style</code>、普通属性和 DOM Prop 分别走不同的更新分支，减少属性比对的对象创建和反射调用 (<a href="https://blog.csdn.net/weixin_40297452/article/details/121143356?utm_source=chatgpt.com" target="_blank" rel="noopener noreferrer">vue3.0性能优化点之静态标记(PatchFlag) 原创 - CSDN博客</a>)。</li><li><code>style=&quot;color:red&quot;</code> 会被字符串转换为静态对象并提升，<code>:style</code> 绑定的表达式则只更新变动字段 (<a href="https://blog.csdn.net/weixin_40297452/article/details/121143356?utm_source=chatgpt.com" target="_blank" rel="noopener noreferrer">vue3.0性能优化点之静态标记(PatchFlag) 原创 - CSDN博客</a>)。</li></ul><hr><h2 id="🛠-指令与插槽编译优化" tabindex="-1"><a class="header-anchor" href="#🛠-指令与插槽编译优化"><span>🛠 指令与插槽编译优化</span></a></h2><h3 id="内置指令-v-for-v-if" tabindex="-1"><a class="header-anchor" href="#内置指令-v-for-v-if"><span>内置指令（v-for/v-if）</span></a></h3><ul><li><strong>v-for</strong>：编译为 <code>renderList(source, (item, index) =&gt; ...)</code>，并默认假设顺序不变，无 key 不移动 (<a href="https://vuejs.org/api/built-in-directives.html?utm_source=chatgpt.com" target="_blank" rel="noopener noreferrer">Built-in Directives | Vue.js</a>)。</li><li><strong>v-if/v-else</strong>：编译为三元表达式或 <code>renderBlock</code> 调用，只在条件变化时创建或移除对应子树 (<a href="https://zhuanlan.zhihu.com/p/181505806?utm_source=chatgpt.com" target="_blank" rel="noopener noreferrer">Vue3 模板编译原理 - 知乎专栏</a>)。</li></ul><h3 id="插槽-slots" tabindex="-1"><a class="header-anchor" href="#插槽-slots"><span>插槽（Slots）</span></a></h3><ul><li>parent 侧在编译时生成 <code>renderSlot(_ctx.$slots, &#39;default&#39;, props)</code> 调用</li><li>child 侧使用 <code>resolveSlots</code> 在运行时将 slot VNode 渲染函数缓存到 <code>instance.slots</code> 对象 (<a href="https://zhuanlan.zhihu.com/p/181505806?utm_source=chatgpt.com" target="_blank" rel="noopener noreferrer">Vue3 模板编译原理 - 知乎专栏</a>)</li><li>这样 slot 渲染函数只生成一次，提升效率。</li></ul><hr><h2 id="🔍-实践建议" tabindex="-1"><a class="header-anchor" href="#🔍-实践建议"><span>🔍 实践建议</span></a></h2><ul><li><strong>开启生产模式</strong>：确保打包时启用 <code>__DEV__</code> 为 false，以移除开发模式的警告和断言。</li><li><strong>添加 <code>key</code></strong>：对动态列表始终加 <code>:key</code>，充分利用 Patch Flag 的 FULL_PROPS + STABLE_FRAGMENT 优化 (<a href="https://m.zpedu.com/it/rjyf/22028.html?utm_source=chatgpt.com" target="_blank" rel="noopener noreferrer">Vue3将Diff进行了哪些优化？ - 中培伟业</a>)。</li><li><strong>避免绑定对象字面量</strong>：将样式或属性对象提取为响应式或常量，触发静态提升。</li><li><strong>合理拆分组件</strong>：对大型复杂模板拆分成多个小组件，利用编译时的子树静态分析减少 diff 代价。</li></ul><hr><p>以上诸多优化策略，使 Vue 3 的模板编译与渲染在典型场景下比 Vue 2 性能提升 2～3 倍，渲染延迟和内存占用显著下降 (<a href="https://blog.csdn.net/weixin_64974855/article/details/131457309?utm_source=chatgpt.com" target="_blank" rel="noopener noreferrer">VUE3-diff算法中的静态提升（Static Hoisting） 原创 - CSDN博客</a>, <a href="https://juejin.cn/post/7084597196359745573?utm_source=chatgpt.com" target="_blank" rel="noopener noreferrer">vue3的改变（hoist 与Block） - 稀土掘金</a>)。</p><blockquote><p><strong>参考链接</strong></p><ul><li>Vue 3 模板编译优化实战：稀土掘金 (<a href="https://juejin.cn/post/7247324653840367675?utm_source=chatgpt.com" target="_blank" rel="noopener noreferrer">Vue3系列三：模版编译及优化的源码解析 - 稀土掘金</a>)</li><li>《vue3编译优化之静态提升》：博客园 (<a href="https://www.cnblogs.com/heavenYJJ/p/18190230?utm_source=chatgpt.com" target="_blank" rel="noopener noreferrer">vue3编译优化之“静态提升” - 前端欧阳- 博客园</a>)</li><li>《Vue 3 性能优化点之静态标记》：CSDN (<a href="https://blog.csdn.net/weixin_40297452/article/details/121143356?utm_source=chatgpt.com" target="_blank" rel="noopener noreferrer">vue3.0性能优化点之静态标记(PatchFlag) 原创 - CSDN博客</a>)</li><li>PatchFlag 官方文档：Vue 指南 (<a href="https://vuejs.org/guide/extras/rendering-mechanism?utm_source=chatgpt.com" target="_blank" rel="noopener noreferrer">Rendering Mechanism - Vue.js</a>)</li><li>PatchFlag 源码：GitHub vuejs/core (<a href="https://github.com/vuejs/core/blob/main/packages/shared/src/patchFlags.ts?utm_source=chatgpt.com" target="_blank" rel="noopener noreferrer">core/packages/shared/src/patchFlags.ts at main · vuejs/core - GitHub</a>)</li><li>Diff 算法优化：支付宝社区 (<a href="https://open.alipay.com/portal/forum/post/108301027?utm_source=chatgpt.com" target="_blank" rel="noopener noreferrer">从面试题入手，畅谈Vue 3 性能优化-支付宝开发者社区</a>)</li><li>编译原理详解：知乎专栏 (<a href="https://zhuanlan.zhihu.com/p/181505806?utm_source=chatgpt.com" target="_blank" rel="noopener noreferrer">Vue3 模板编译原理 - 知乎专栏</a>)</li></ul></blockquote>`,38)]))}const h=t(n,[["render",l]]),p=JSON.parse('{"path":"/posts/vue/vue3/%E6%A8%A1%E6%9D%BF%E7%BC%96%E8%AF%91.html","title":"Vue3 模板编译优化","lang":"zh-CN","frontmatter":{"title":"Vue3 模板编译优化","tags":["vue"],"description":"下面文章从 模板编译优化 的几个核心维度入手，结合多篇实战与源码解析，全面介绍 Vue 3 如何通过静态分析与编译时标记，减少运行时成本、加速虚拟 DOM 渲染。 Vue 3 的模板编译优化主要体现在以下几点： 静态提升（Static Hoisting）：将真正不变的节点提取到渲染函数外层，避免每次重新创建 (vue3编译优化之“静态提升” - 前端欧...","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/zy-vuepress/posts/vue/vue3/%E6%A8%A1%E6%9D%BF%E7%BC%96%E8%AF%91.html"}],["meta",{"property":"og:site_name","content":"我的基地"}],["meta",{"property":"og:title","content":"Vue3 模板编译优化"}],["meta",{"property":"og:description","content":"下面文章从 模板编译优化 的几个核心维度入手，结合多篇实战与源码解析，全面介绍 Vue 3 如何通过静态分析与编译时标记，减少运行时成本、加速虚拟 DOM 渲染。 Vue 3 的模板编译优化主要体现在以下几点： 静态提升（Static Hoisting）：将真正不变的节点提取到渲染函数外层，避免每次重新创建 (vue3编译优化之“静态提升” - 前端欧..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-05-20T07:48:26.000Z"}],["meta",{"property":"article:tag","content":"vue"}],["meta",{"property":"article:modified_time","content":"2025-05-20T07:48:26.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Vue3 模板编译优化\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-05-20T07:48:26.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Mrs.Zoe\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"📝 模板编译概览","slug":"📝-模板编译概览","link":"#📝-模板编译概览","children":[]},{"level":2,"title":"🚀 静态提升（Static Hoisting）","slug":"🚀-静态提升-static-hoisting","link":"#🚀-静态提升-static-hoisting","children":[{"level":3,"title":"原理与目的","slug":"原理与目的","link":"#原理与目的","children":[]},{"level":3,"title":"源码实现","slug":"源码实现","link":"#源码实现","children":[]}]},{"level":2,"title":"🎯 Patch Flag 与 Block Tree","slug":"🎯-patch-flag-与-block-tree","link":"#🎯-patch-flag-与-block-tree","children":[{"level":3,"title":"Patch Flag 精细标记","slug":"patch-flag-精细标记","link":"#patch-flag-精细标记","children":[]},{"level":3,"title":"Block Tree + dynamicChildren","slug":"block-tree-dynamicchildren","link":"#block-tree-dynamicchildren","children":[]}]},{"level":2,"title":"🔄 事件与绑定优化","slug":"🔄-事件与绑定优化","link":"#🔄-事件与绑定优化","children":[{"level":3,"title":"复用事件处理函数","slug":"复用事件处理函数","link":"#复用事件处理函数","children":[]},{"level":3,"title":"动态属性快速路径","slug":"动态属性快速路径","link":"#动态属性快速路径","children":[]}]},{"level":2,"title":"🛠 指令与插槽编译优化","slug":"🛠-指令与插槽编译优化","link":"#🛠-指令与插槽编译优化","children":[{"level":3,"title":"内置指令（v-for/v-if）","slug":"内置指令-v-for-v-if","link":"#内置指令-v-for-v-if","children":[]},{"level":3,"title":"插槽（Slots）","slug":"插槽-slots","link":"#插槽-slots","children":[]}]},{"level":2,"title":"🔍 实践建议","slug":"🔍-实践建议","link":"#🔍-实践建议","children":[]}],"git":{"createdTime":1745897858000,"updatedTime":1747727306000,"contributors":[{"name":"zy","username":"zy","email":"891374900@qq.com","commits":2,"url":"https://github.com/zy"},{"name":"zouyu","username":"zouyu","email":"891374900@qq.com","commits":1,"url":"https://github.com/zouyu"}]},"readingTime":{"minutes":6.17,"words":1851},"filePathRelative":"posts/vue/vue3/模板编译.md","localizedDate":"2025年4月29日","excerpt":"<p>下面文章从 <strong>模板编译优化</strong> 的几个核心维度入手，结合多篇实战与源码解析，全面介绍 Vue 3 如何通过静态分析与编译时标记，减少运行时成本、加速虚拟 DOM 渲染。</p>\\n<p>Vue 3 的模板编译优化主要体现在以下几点：</p>\\n<ul>\\n<li><strong>静态提升（Static Hoisting）</strong>：将真正不变的节点提取到渲染函数外层，避免每次重新创建  (<a href=\\"https://www.cnblogs.com/heavenYJJ/p/18190230?utm_source=chatgpt.com\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">vue3编译优化之“静态提升” - 前端欧阳- 博客园</a>)。</li>\\n<li><strong>Patch Flag &amp; Block Tree</strong>：编译器为动态节点打上精细的“更新标记”，并用 Block Tree+dynamicChildren 列出真正需更新的子树，跳过大部分比对  (<a href=\\"https://blog.csdn.net/weixin_40297452/article/details/121143356?utm_source=chatgpt.com\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">vue3.0性能优化点之静态标记(PatchFlag) 原创 - CSDN博客</a>, <a href=\\"https://open.alipay.com/portal/forum/post/108301027?utm_source=chatgpt.com\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">从面试题入手，畅谈Vue 3 性能优化-支付宝开发者社区</a>)。</li>\\n<li><strong>事件与属性绑定优化</strong>：对动态 class、style、props 和事件处理函数生成最小化的更新逻辑，复用相同回调并减少开销  (<a href=\\"https://zhuanlan.zhihu.com/p/150732926?utm_source=chatgpt.com\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">Vue3 Compiler 优化细节，如何手写高性能渲染函数 - 知乎专栏</a>, <a href=\\"https://vuejs.org/guide/extras/rendering-mechanism?utm_source=chatgpt.com\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">Rendering Mechanism - Vue.js</a>)。</li>\\n<li><strong>指令与插槽编译</strong>：对内置指令（如 v-for、v-if）和插槽做特殊代码生成，提前计算分支与缓存结果  (<a href=\\"https://zhuanlan.zhihu.com/p/181505806?utm_source=chatgpt.com\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">Vue3 模板编译原理 - 知乎专栏</a>, <a href=\\"https://vuejs.org/api/built-in-directives.html?utm_source=chatgpt.com\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">Built-in Directives | Vue.js</a>)。</li>\\n</ul>","autoDesc":true}');export{h as comp,p as data};
