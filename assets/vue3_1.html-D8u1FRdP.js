import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as t,e as n,o as a}from"./app-D4yN_ylH.js";const e={};function h(l,s){return a(),t("div",null,s[0]||(s[0]=[n(`<h2 id="🔥-vue-3-计算属性-vs-watch-为什么计算属性不能有副作用" tabindex="-1"><a class="header-anchor" href="#🔥-vue-3-计算属性-vs-watch-为什么计算属性不能有副作用"><span><strong>🔥 Vue 3 计算属性 vs. <code>watch</code>，为什么计算属性不能有副作用？</strong></span></a></h2><p>在 Vue 3 中，<strong>计算属性（computed）</strong> 和 <strong><code>watch</code> 监听器</strong> 都用于<strong>响应数据的变化</strong>，但它们的用途和实现方式不同：</p><table><thead><tr><th><strong>对比项</strong></th><th><strong>计算属性 (<code>computed</code>)</strong></th><th><strong>监听器 (<code>watch</code>)</strong></th></tr></thead><tbody><tr><td><strong>作用</strong></td><td>依赖变化时 <strong>返回计算结果</strong></td><td>依赖变化时 <strong>执行副作用</strong></td></tr><tr><td><strong>是否缓存</strong></td><td>✅ <strong>缓存结果</strong>，只有依赖变化时才重新计算</td><td>❌ <strong>不会缓存</strong>，每次依赖变化都会执行</td></tr><tr><td><strong>是否有副作用</strong></td><td>❌ <strong>不能有副作用</strong></td><td>✅ <strong>可以有副作用</strong></td></tr><tr><td><strong>适用场景</strong></td><td>计算派生数据（如 <code>fullName</code>）</td><td>处理异步请求、手动执行逻辑</td></tr></tbody></table><hr><h2 id="🚀-计算属性为什么不能有副作用" tabindex="-1"><a class="header-anchor" href="#🚀-计算属性为什么不能有副作用"><span><strong>🚀 计算属性为什么不能有副作用？</strong></span></a></h2><h3 id="✅-计算属性的本质" tabindex="-1"><a class="header-anchor" href="#✅-计算属性的本质"><span><strong>✅ 计算属性的本质</strong></span></a></h3><p>计算属性 <strong>本质上是一个 <code>watchEffect</code></strong>，<strong>但带有缓存</strong>，Vue 3 在内部通过 <code>effect()</code> 处理 <strong>依赖收集和响应更新</strong>。</p><p>计算属性的特点：</p><ol><li><strong>缓存结果</strong>：只有依赖发生变化时才会重新计算。</li><li><strong>依赖追踪</strong>：Vue 追踪它内部用到的响应式数据。</li><li><strong>同步返回值</strong>：计算属性的值可以直接用于模板或代码逻辑中。</li></ol><h3 id="❌-如果计算属性有副作用-会导致意外的行为" tabindex="-1"><a class="header-anchor" href="#❌-如果计算属性有副作用-会导致意外的行为"><span><strong>❌ 如果计算属性有副作用，会导致意外的行为</strong></span></a></h3><div class="language-typescript line-numbers-mode" data-highlighter="shiki" data-ext="typescript" data-title="typescript" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">import</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> { </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">ref</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">computed</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> } </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">from</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;vue&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#986801;--shiki-dark:#E5C07B;"> count</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> ref</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#986801;--shiki-dark:#E5C07B;"> doubleCount</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> computed</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(() </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">  console</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;计算属性执行副作用！&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">); </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// ❌ 不推荐！</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  return</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> count</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">value</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> *</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">});</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">count</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">value</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">++</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">; </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 触发 doubleCount 重新计算</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>📌 <strong>问题：</strong></p><ul><li>每次 <code>count.value</code> 变化，<code>computed</code> 都会执行副作用（<code>console.log</code>）。</li><li>由于 <strong>computed 可能会被多次访问</strong>，可能导致<strong>副作用被多次执行</strong>。</li><li><strong>Vue 会缓存计算结果</strong>，但如果 <code>computed</code> 访问了 <strong>不相关的数据</strong>，Vue 可能会错误地优化它的更新。</li></ul><p><strong>🚫 计算属性的设计目标是派生数据，而不是执行额外逻辑！</strong></p><hr><h2 id="🚀-为什么-watch-可以有副作用" tabindex="-1"><a class="header-anchor" href="#🚀-为什么-watch-可以有副作用"><span><strong>🚀 为什么 <code>watch</code> 可以有副作用？</strong></span></a></h2><h3 id="✅-watch-本质上是一个独立的副作用-effect" tabindex="-1"><a class="header-anchor" href="#✅-watch-本质上是一个独立的副作用-effect"><span><strong>✅ <code>watch</code> 本质上是一个独立的副作用 (<code>effect</code>)</strong></span></a></h3><p><code>watch</code> 的核心作用：</p><ul><li><strong>观察数据变化</strong>，并执行<strong>回调函数</strong>（可以有副作用）。</li><li><strong>不缓存结果</strong>，每次依赖变化时都会执行回调。</li><li><strong>适用于异步操作、手动执行逻辑（如 API 请求）</strong>。</li></ul><div class="language-typescript line-numbers-mode" data-highlighter="shiki" data-ext="typescript" data-title="typescript" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">import</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> { </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">ref</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">watch</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> } </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">from</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;vue&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#986801;--shiki-dark:#E5C07B;"> count</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> ref</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">watch</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">count</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, (</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">newValue</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">oldValue</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">  console</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">\`count 变了: </span><span style="--shiki-light:#CA1243;--shiki-dark:#C678DD;">\${</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">oldValue</span><span style="--shiki-light:#CA1243;--shiki-dark:#C678DD;">}</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> -&gt; </span><span style="--shiki-light:#CA1243;--shiki-dark:#C678DD;">\${</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">newValue</span><span style="--shiki-light:#CA1243;--shiki-dark:#C678DD;">}</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">\`</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // ✅ 副作用：可以执行 API 请求、修改 DOM 等</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">});</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>📌 <strong>为什么 <code>watch</code> 可以有副作用？</strong></p><ol><li><strong>不会缓存</strong>，每次依赖变化都会执行回调，所以副作用不会被跳过。</li><li><strong>明确的触发机制</strong>，只有当监听的数据发生变化时才会执行回调，副作用的执行逻辑可控。</li><li><strong>副作用只发生一次</strong>，不像 <code>computed</code> 可能会被多次访问。</li></ol><hr><h2 id="🚀-计算属性-vs-watch-实际应用场景" tabindex="-1"><a class="header-anchor" href="#🚀-计算属性-vs-watch-实际应用场景"><span><strong>🚀 计算属性 vs. <code>watch</code> 实际应用场景</strong></span></a></h2><table><thead><tr><th><strong>场景</strong></th><th><strong>使用 <code>computed</code></strong></th><th><strong>使用 <code>watch</code></strong></th></tr></thead><tbody><tr><td><strong>模板中的派生数据</strong></td><td>✅ <code>computed</code> 最适合</td><td>❌ 不适合</td></tr><tr><td><strong>监听数据变化并触发异步操作</strong></td><td>❌ 不适合</td><td>✅ <code>watch</code> 最适合</td></tr><tr><td><strong>缓存计算结果</strong></td><td>✅ <code>computed</code> 自动缓存</td><td>❌ <code>watch</code> 不缓存</td></tr><tr><td><strong>执行副作用（如 API 请求）</strong></td><td>❌ 不能有副作用</td><td>✅ 适用于副作用</td></tr></tbody></table><h3 id="✅-示例-1-适合-computed-的场景" tabindex="-1"><a class="header-anchor" href="#✅-示例-1-适合-computed-的场景"><span><strong>✅ 示例 1：适合 <code>computed</code> 的场景</strong></span></a></h3><div class="language-typescript line-numbers-mode" data-highlighter="shiki" data-ext="typescript" data-title="typescript" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#986801;--shiki-dark:#E5C07B;"> firstName</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> ref</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;John&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#986801;--shiki-dark:#E5C07B;"> lastName</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> ref</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;Doe&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#986801;--shiki-dark:#E5C07B;"> fullName</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> computed</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(() </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  return</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> \`</span><span style="--shiki-light:#CA1243;--shiki-dark:#C678DD;">\${</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">firstName</span><span style="--shiki-light:#50A14F;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">value</span><span style="--shiki-light:#CA1243;--shiki-dark:#C678DD;">}</span><span style="--shiki-light:#CA1243;--shiki-dark:#C678DD;"> \${</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">lastName</span><span style="--shiki-light:#50A14F;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">value</span><span style="--shiki-light:#CA1243;--shiki-dark:#C678DD;">}</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">\`</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">});</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>📌 <strong><code>fullName</code> 是 <code>firstName</code> 和 <code>lastName</code> 的派生数据，应该使用 <code>computed</code></strong>。</p><hr><h3 id="✅-示例-2-适合-watch-的场景" tabindex="-1"><a class="header-anchor" href="#✅-示例-2-适合-watch-的场景"><span><strong>✅ 示例 2：适合 <code>watch</code> 的场景</strong></span></a></h3><div class="language-typescript line-numbers-mode" data-highlighter="shiki" data-ext="typescript" data-title="typescript" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">watch</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">fullName</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, (</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">newVal</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">  console</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;用户全名变了！&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">newVal</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // ✅ 可以发送 API 请求、写日志等</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">});</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>📌 <strong>这里 <code>watch</code> 用于监听 <code>fullName</code> 变化，并触发副作用</strong>。</p><hr><h2 id="🎯-总结" tabindex="-1"><a class="header-anchor" href="#🎯-总结"><span><strong>🎯 总结</strong></span></a></h2><table><thead><tr><th><strong>特性</strong></th><th><strong>计算属性（computed）</strong></th><th><strong>监听器（watch）</strong></th></tr></thead><tbody><tr><td><strong>是否缓存</strong></td><td>✅ <strong>缓存结果</strong></td><td>❌ <strong>不缓存</strong></td></tr><tr><td><strong>是否有副作用</strong></td><td>❌ 不能有副作用</td><td>✅ 可以有副作用</td></tr><tr><td><strong>适用场景</strong></td><td>计算派生数据，如 <code>fullName</code></td><td>监听数据变化，触发 API 调用等</td></tr><tr><td><strong>执行时机</strong></td><td><strong>在模板/代码中被访问时执行</strong></td><td><strong>数据变化时执行</strong></td></tr><tr><td><strong>Vue 内部实现</strong></td><td><strong>基于 <code>effect</code>，带缓存</strong></td><td><strong>基于 <code>effect</code>，无缓存</strong></td></tr></tbody></table><h3 id="🔥-为什么计算属性不能有副作用" tabindex="-1"><a class="header-anchor" href="#🔥-为什么计算属性不能有副作用"><span><strong>🔥 为什么计算属性不能有副作用？</strong></span></a></h3><ol><li><strong>计算属性会被缓存</strong>，可能导致副作用<strong>不会每次都执行</strong>。</li><li><strong>计算属性会被模板或代码访问多次</strong>，可能导致<strong>副作用执行多次</strong>，造成<strong>意外行为</strong>。</li><li><strong>Vue 内部优化</strong> 可能会跳过不必要的计算，导致副作用<strong>不稳定</strong>。</li></ol><h3 id="🔥-为什么-watch-可以有副作用" tabindex="-1"><a class="header-anchor" href="#🔥-为什么-watch-可以有副作用"><span><strong>🔥 为什么 <code>watch</code> 可以有副作用？</strong></span></a></h3><ol><li><strong>每次数据变化时都会执行</strong>，不会缓存，所以副作用可以安全执行。</li><li><strong>专门设计用于副作用</strong>，如 API 请求、日志记录等。</li><li><strong>避免了 <code>computed</code> 副作用的潜在问题</strong>，保证逻辑清晰。</li></ol><hr><h2 id="🔥-总结建议" tabindex="-1"><a class="header-anchor" href="#🔥-总结建议"><span><strong>🔥 总结建议</strong></span></a></h2><ul><li><strong>需要计算数据时，使用 <code>computed</code></strong>（不能有副作用）。</li><li><strong>需要监听数据并触发副作用时，使用 <code>watch</code></strong>（可以有副作用）。</li><li><strong>在 <code>computed</code> 里不要写 <code>console.log</code>、API 请求等副作用代码，否则可能会有不可预期的行为。</strong></li></ul>`,42)]))}const o=i(e,[["render",h]]),p=JSON.parse('{"path":"/posts/vue/vue3/vue3_1.html","title":"vue3 computed 和 watch","lang":"zh-CN","frontmatter":{"title":"vue3 computed 和 watch","tags":["vue3"],"description":"🔥 Vue 3 计算属性 vs. watch，为什么计算属性不能有副作用？ 在 Vue 3 中，计算属性（computed） 和 watch 监听器 都用于响应数据的变化，但它们的用途和实现方式不同： 🚀 计算属性为什么不能有副作用？ ✅ 计算属性的本质 计算属性 本质上是一个 watchEffect，但带有缓存，Vue 3 在内部通过 effec...","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/zy-vuepress/posts/vue/vue3/vue3_1.html"}],["meta",{"property":"og:site_name","content":"我的基地"}],["meta",{"property":"og:title","content":"vue3 computed 和 watch"}],["meta",{"property":"og:description","content":"🔥 Vue 3 计算属性 vs. watch，为什么计算属性不能有副作用？ 在 Vue 3 中，计算属性（computed） 和 watch 监听器 都用于响应数据的变化，但它们的用途和实现方式不同： 🚀 计算属性为什么不能有副作用？ ✅ 计算属性的本质 计算属性 本质上是一个 watchEffect，但带有缓存，Vue 3 在内部通过 effec..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-05-20T07:48:26.000Z"}],["meta",{"property":"article:tag","content":"vue3"}],["meta",{"property":"article:modified_time","content":"2025-05-20T07:48:26.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"vue3 computed 和 watch\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-05-20T07:48:26.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Mrs.Zoe\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"🔥 Vue 3 计算属性 vs. watch，为什么计算属性不能有副作用？","slug":"🔥-vue-3-计算属性-vs-watch-为什么计算属性不能有副作用","link":"#🔥-vue-3-计算属性-vs-watch-为什么计算属性不能有副作用","children":[]},{"level":2,"title":"🚀 计算属性为什么不能有副作用？","slug":"🚀-计算属性为什么不能有副作用","link":"#🚀-计算属性为什么不能有副作用","children":[{"level":3,"title":"✅ 计算属性的本质","slug":"✅-计算属性的本质","link":"#✅-计算属性的本质","children":[]},{"level":3,"title":"❌ 如果计算属性有副作用，会导致意外的行为","slug":"❌-如果计算属性有副作用-会导致意外的行为","link":"#❌-如果计算属性有副作用-会导致意外的行为","children":[]}]},{"level":2,"title":"🚀 为什么 watch 可以有副作用？","slug":"🚀-为什么-watch-可以有副作用","link":"#🚀-为什么-watch-可以有副作用","children":[{"level":3,"title":"✅ watch 本质上是一个独立的副作用 (effect)","slug":"✅-watch-本质上是一个独立的副作用-effect","link":"#✅-watch-本质上是一个独立的副作用-effect","children":[]}]},{"level":2,"title":"🚀 计算属性 vs. watch 实际应用场景","slug":"🚀-计算属性-vs-watch-实际应用场景","link":"#🚀-计算属性-vs-watch-实际应用场景","children":[{"level":3,"title":"✅ 示例 1：适合 computed 的场景","slug":"✅-示例-1-适合-computed-的场景","link":"#✅-示例-1-适合-computed-的场景","children":[]},{"level":3,"title":"✅ 示例 2：适合 watch 的场景","slug":"✅-示例-2-适合-watch-的场景","link":"#✅-示例-2-适合-watch-的场景","children":[]}]},{"level":2,"title":"🎯 总结","slug":"🎯-总结","link":"#🎯-总结","children":[{"level":3,"title":"🔥 为什么计算属性不能有副作用？","slug":"🔥-为什么计算属性不能有副作用","link":"#🔥-为什么计算属性不能有副作用","children":[]},{"level":3,"title":"🔥 为什么 watch 可以有副作用？","slug":"🔥-为什么-watch-可以有副作用","link":"#🔥-为什么-watch-可以有副作用","children":[]}]},{"level":2,"title":"🔥 总结建议","slug":"🔥-总结建议","link":"#🔥-总结建议","children":[]}],"git":{"createdTime":1742552511000,"updatedTime":1747727306000,"contributors":[{"name":"zy","username":"zy","email":"891374900@qq.com","commits":4,"url":"https://github.com/zy"},{"name":"zouyu","username":"zouyu","email":"891374900@qq.com","commits":1,"url":"https://github.com/zouyu"}]},"readingTime":{"minutes":3.98,"words":1195},"filePathRelative":"posts/vue/vue3/vue3_1.md","localizedDate":"2025年3月21日","excerpt":"<h2><strong>🔥 Vue 3 计算属性 vs. <code>watch</code>，为什么计算属性不能有副作用？</strong></h2>\\n<p>在 Vue 3 中，<strong>计算属性（computed）</strong> 和 <strong><code>watch</code> 监听器</strong> 都用于<strong>响应数据的变化</strong>，但它们的用途和实现方式不同：</p>\\n<table>\\n<thead>\\n<tr>\\n<th><strong>对比项</strong></th>\\n<th><strong>计算属性 (<code>computed</code>)</strong></th>\\n<th><strong>监听器 (<code>watch</code>)</strong></th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td><strong>作用</strong></td>\\n<td>依赖变化时 <strong>返回计算结果</strong></td>\\n<td>依赖变化时 <strong>执行副作用</strong></td>\\n</tr>\\n<tr>\\n<td><strong>是否缓存</strong></td>\\n<td>✅ <strong>缓存结果</strong>，只有依赖变化时才重新计算</td>\\n<td>❌ <strong>不会缓存</strong>，每次依赖变化都会执行</td>\\n</tr>\\n<tr>\\n<td><strong>是否有副作用</strong></td>\\n<td>❌ <strong>不能有副作用</strong></td>\\n<td>✅ <strong>可以有副作用</strong></td>\\n</tr>\\n<tr>\\n<td><strong>适用场景</strong></td>\\n<td>计算派生数据（如 <code>fullName</code>）</td>\\n<td>处理异步请求、手动执行逻辑</td>\\n</tr>\\n</tbody>\\n</table>","autoDesc":true}');export{o as comp,p as data};
