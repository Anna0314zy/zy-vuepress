import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as e,e as a,o as t}from"./app-D4yN_ylH.js";const n={};function l(h,i){return t(),e("div",null,i[0]||(i[0]=[a(`<p>React 16 引入 Fiber 架构后，整个更新流程被拆分成多个阶段，目的是实现更细粒度的控制和打断能力（cooperative scheduling），但 <strong>React 16 实际上并未实现时间切片的打断式更新（如 <code>shouldYield</code>）</strong>，这是 React 18 中 concurrent 模式才真正具备的能力。</p><p>不过 React 16 的 Fiber 架构<strong>为后续实现异步渲染打下了架构基础</strong>。</p><hr><h1 id="🧬-react-16-fiber-的完整更新流程" tabindex="-1"><a class="header-anchor" href="#🧬-react-16-fiber-的完整更新流程"><span>🧬 React 16 Fiber 的完整更新流程</span></a></h1><p>React 16 中的 Fiber 架构把更新流程拆成三个核心阶段：</p><hr><h3 id="🟡-1-调度阶段-schedule-phase" tabindex="-1"><a class="header-anchor" href="#🟡-1-调度阶段-schedule-phase"><span>🟡 1. 调度阶段（Schedule Phase）</span></a></h3><h4 id="⛳-入口函数" tabindex="-1"><a class="header-anchor" href="#⛳-入口函数"><span>⛳ 入口函数</span></a></h4><ul><li>类组件：<code>setState</code> / <code>forceUpdate</code></li><li>函数组件：通过 <code>ReactDOM.render()</code> 或内部更新触发</li></ul><p>最终调用：</p><div class="language-ts line-numbers-mode" data-highlighter="shiki" data-ext="ts" data-title="ts" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">scheduleUpdateOnFiber</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">fiber</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">lane</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">eventTime</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h4 id="✅-主要任务" tabindex="-1"><a class="header-anchor" href="#✅-主要任务"><span>✅ 主要任务</span></a></h4><ul><li>找到更新的 Root 节点；</li><li>把更新任务加入到调度队列中；</li><li>设置更新的优先级（React 16 使用 expirationTime）；</li><li>准备开始渲染任务。</li></ul><p>React 16 使用的是过期时间 <code>expirationTime</code>，而非 Lane 模型：</p><div class="language-ts line-numbers-mode" data-highlighter="shiki" data-ext="ts" data-title="ts" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">markUpdateTimeFromFiberToRoot</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">fiber</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">expirationTime</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">ensureRootIsScheduled</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">root</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><hr><h3 id="🟡-2-渲染阶段-render-phase" tabindex="-1"><a class="header-anchor" href="#🟡-2-渲染阶段-render-phase"><span>🟡 2. 渲染阶段（Render Phase）</span></a></h3><h4 id="✅-任务目标" tabindex="-1"><a class="header-anchor" href="#✅-任务目标"><span>✅ 任务目标</span></a></h4><ul><li>从当前 Fiber 树（<code>current</code>）构造出新的 <code>workInProgress</code> 树；</li><li>执行 <code>beginWork</code> 和 <code>completeWork</code>；</li><li>构建 <code>effectList</code>，标记需要更新的节点；</li><li>如果中途抛出错误，则进入 <code>capture</code> 机制（React 16 引入了错误边界）。</li></ul><h4 id="🔁-执行流程" tabindex="-1"><a class="header-anchor" href="#🔁-执行流程"><span>🔁 执行流程</span></a></h4><div class="language-ts line-numbers-mode" data-highlighter="shiki" data-ext="ts" data-title="ts" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">while</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">workInProgress</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> !==</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">  performUnitOfWork</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">workInProgress</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-ts line-numbers-mode" data-highlighter="shiki" data-ext="ts" data-title="ts" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">function</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> performUnitOfWork</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">unitOfWork</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  const</span><span style="--shiki-light:#986801;--shiki-dark:#E5C07B;"> current</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> unitOfWork</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">alternate</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  let</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> next</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> beginWork</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">current</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">unitOfWork</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  if</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">next</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> ===</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">    completeUnitOfWork</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">unitOfWork</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  } </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">else</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    workInProgress</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> next</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="🔄-fiber-树的遍历过程" tabindex="-1"><a class="header-anchor" href="#🔄-fiber-树的遍历过程"><span>🔄 Fiber 树的遍历过程</span></a></h4><ol><li><code>beginWork()</code>：为当前节点创建子节点；</li><li><code>completeWork()</code>：处理当前节点副作用，生成 DOM；</li><li>在 Fiber 树中深度优先遍历。</li></ol><p>⚠️ React 16 虽然使用 Fiber 栈帧结构（协程），但并<strong>未实现中断逻辑（没有 <code>shouldYield()</code> 判断）</strong>，因此在主线程上是同步执行的。</p><hr><h3 id="🟡-3-提交阶段-commit-phase" tabindex="-1"><a class="header-anchor" href="#🟡-3-提交阶段-commit-phase"><span>🟡 3. 提交阶段（Commit Phase）</span></a></h3><p>这是最终将 DOM 更新到页面的阶段。</p><h4 id="⛳-入口函数-1" tabindex="-1"><a class="header-anchor" href="#⛳-入口函数-1"><span>⛳ 入口函数</span></a></h4><div class="language-ts line-numbers-mode" data-highlighter="shiki" data-ext="ts" data-title="ts" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">commitRoot</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">root</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h4 id="✅-阶段划分" tabindex="-1"><a class="header-anchor" href="#✅-阶段划分"><span>✅ 阶段划分</span></a></h4><p>分为三个子阶段：</p><table><thead><tr><th>阶段</th><th>说明</th></tr></thead><tbody><tr><td><code>beforeMutation</code></td><td>生命周期 <code>getSnapshotBeforeUpdate</code> 等</td></tr><tr><td><code>mutation</code></td><td>插入、更新、删除 DOM</td></tr><tr><td><code>layout</code></td><td>执行生命周期：<code>componentDidMount</code> / <code>useEffect</code></td></tr></tbody></table><p>此阶段是同步执行、不可打断的。</p><hr><h2 id="🧩-react-16-fiber-流程图概览" tabindex="-1"><a class="header-anchor" href="#🧩-react-16-fiber-流程图概览"><span>🧩 React 16 Fiber 流程图概览</span></a></h2><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>setState / forceUpdate</span></span>
<span class="line"><span>        ↓</span></span>
<span class="line"><span>scheduleUpdateOnFiber</span></span>
<span class="line"><span>        ↓</span></span>
<span class="line"><span>React 内部调度器设置 expirationTime</span></span>
<span class="line"><span>        ↓</span></span>
<span class="line"><span>开始构建 workInProgress Fiber 树</span></span>
<span class="line"><span>        ↓</span></span>
<span class="line"><span>beginWork → completeWork</span></span>
<span class="line"><span>        ↓</span></span>
<span class="line"><span>生成 effectList</span></span>
<span class="line"><span>        ↓</span></span>
<span class="line"><span>commitRoot → 提交到真实 DOM</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h2 id="📌-小结-react-16-与后续版本的差异" tabindex="-1"><a class="header-anchor" href="#📌-小结-react-16-与后续版本的差异"><span>📌 小结：React 16 与后续版本的差异</span></a></h2><table><thead><tr><th>特性</th><th>React 16</th><th>React 17</th><th>React 18</th></tr></thead><tbody><tr><td>Fiber 架构</td><td>✅</td><td>✅</td><td>✅</td></tr><tr><td>中断式渲染（shouldYield）</td><td>❌</td><td>❌</td><td>✅（开启 Concurrent）</td></tr><tr><td>时间切片</td><td>❌</td><td>❌</td><td>✅</td></tr><tr><td>Lane 模型</td><td>❌（使用 expirationTime）</td><td>❌</td><td>✅</td></tr><tr><td>Concurrent 模式</td><td>❌</td><td>❌</td><td>✅</td></tr></tbody></table><hr>`,41)]))}const p=s(n,[["render",l]]),c=JSON.parse('{"path":"/posts/react/reactFiber16.html","title":"🧬 React 16 Fiber 的完整更新流程","lang":"zh-CN","frontmatter":{"description":"React 16 引入 Fiber 架构后，整个更新流程被拆分成多个阶段，目的是实现更细粒度的控制和打断能力（cooperative scheduling），但 React 16 实际上并未实现时间切片的打断式更新（如 shouldYield），这是 React 18 中 concurrent 模式才真正具备的能力。 不过 React 16 的 Fib...","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/zy-vuepress/posts/react/reactFiber16.html"}],["meta",{"property":"og:site_name","content":"我的基地"}],["meta",{"property":"og:title","content":"🧬 React 16 Fiber 的完整更新流程"}],["meta",{"property":"og:description","content":"React 16 引入 Fiber 架构后，整个更新流程被拆分成多个阶段，目的是实现更细粒度的控制和打断能力（cooperative scheduling），但 React 16 实际上并未实现时间切片的打断式更新（如 shouldYield），这是 React 18 中 concurrent 模式才真正具备的能力。 不过 React 16 的 Fib..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-05-09T11:25:45.000Z"}],["meta",{"property":"article:modified_time","content":"2025-05-09T11:25:45.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"🧬 React 16 Fiber 的完整更新流程\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-05-09T11:25:45.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Mrs.Zoe\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":3,"title":"🟡 1. 调度阶段（Schedule Phase）","slug":"🟡-1-调度阶段-schedule-phase","link":"#🟡-1-调度阶段-schedule-phase","children":[]},{"level":3,"title":"🟡 2. 渲染阶段（Render Phase）","slug":"🟡-2-渲染阶段-render-phase","link":"#🟡-2-渲染阶段-render-phase","children":[]},{"level":3,"title":"🟡 3. 提交阶段（Commit Phase）","slug":"🟡-3-提交阶段-commit-phase","link":"#🟡-3-提交阶段-commit-phase","children":[]},{"level":2,"title":"🧩 React 16 Fiber 流程图概览","slug":"🧩-react-16-fiber-流程图概览","link":"#🧩-react-16-fiber-流程图概览","children":[]},{"level":2,"title":"📌 小结：React 16 与后续版本的差异","slug":"📌-小结-react-16-与后续版本的差异","link":"#📌-小结-react-16-与后续版本的差异","children":[]}],"git":{"createdTime":1746789945000,"updatedTime":1746789945000,"contributors":[{"name":"zouyu","username":"zouyu","email":"891374900@qq.com","commits":1,"url":"https://github.com/zouyu"}]},"readingTime":{"minutes":1.95,"words":585},"filePathRelative":"posts/react/reactFiber16.md","localizedDate":"2025年5月9日","excerpt":"<p>React 16 引入 Fiber 架构后，整个更新流程被拆分成多个阶段，目的是实现更细粒度的控制和打断能力（cooperative scheduling），但 <strong>React 16 实际上并未实现时间切片的打断式更新（如 <code>shouldYield</code>）</strong>，这是 React 18 中 concurrent 模式才真正具备的能力。</p>\\n<p>不过 React 16 的 Fiber 架构<strong>为后续实现异步渲染打下了架构基础</strong>。</p>\\n<hr>\\n<h1>🧬 React 16 Fiber 的完整更新流程</h1>","autoDesc":true}');export{p as comp,c as data};
