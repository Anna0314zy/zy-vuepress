import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,e,o as n}from"./app-D4yN_ylH.js";const l={};function t(h,i){return n(),a("div",null,i[0]||(i[0]=[e(`<hr><h1 id="🌟-vue-3-组件的渲染与异步更新原理详解" tabindex="-1"><a class="header-anchor" href="#🌟-vue-3-组件的渲染与异步更新原理详解"><span>🌟 Vue 3 组件的渲染与异步更新原理详解</span></a></h1><p>Vue 3 在实现细节上有很多重构和优化，特别是在组件渲染流程和异步更新机制方面。本篇文档将围绕以下三个部分展开深入讲解：</p><ol><li><a href="#1-%E7%BB%84%E4%BB%B6%E7%9A%84%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B">Vue 3 组件的渲染流程</a></li><li><a href="#2-%E5%BC%82%E6%AD%A5%E6%9B%B4%E6%96%B0%E6%9C%BA%E5%88%B6">Vue 3 的异步更新原理（nextTick &amp; 更新队列）</a></li><li><a href="#3-%E7%BB%84%E4%BB%B6%E6%9B%B4%E6%96%B0%E6%B5%81%E7%A8%8B">组件更新流程（属性变更、状态响应）</a></li></ol><hr><h2 id="_1-组件的渲染流程" tabindex="-1"><a class="header-anchor" href="#_1-组件的渲染流程"><span>1. 组件的渲染流程</span></a></h2><p>Vue 3 的渲染是基于 Virtual DOM 和 Proxy 响应式系统驱动的。整个流程可以拆解为几个关键阶段：</p><h3 id="🧱-初始化渲染流程" tabindex="-1"><a class="header-anchor" href="#🧱-初始化渲染流程"><span>🧱 初始化渲染流程</span></a></h3><ol><li><p><strong>创建组件实例（<code>createComponentInstance</code>）</strong></p><ul><li>设置组件的 <code>props</code>、<code>slots</code>、<code>setupState</code> 等；</li><li>创建 <code>proxy</code> 代理访问。</li></ul></li><li><p><strong>执行 setup 函数</strong>（如果是 Composition API）</p><ul><li>setup 中可使用 reactive/ref 等响应式数据；</li><li>返回值绑定到 <code>ctx</code>，供模板使用。</li></ul></li><li><p><strong>创建渲染函数（render）</strong></p><ul><li>编译 <code>.vue</code> 文件的模板为 <code>render</code> 函数；</li><li>执行 <code>render</code> 返回 Virtual DOM。</li></ul></li><li><p><strong>执行 patch（核心 diff 函数）</strong></p><ul><li>对比 Virtual DOM；</li><li>首次挂载时执行 <code>mountElement</code>；</li><li>创建真实 DOM 并插入到容器中。</li></ul></li></ol><h3 id="🖼️-渲染简图" tabindex="-1"><a class="header-anchor" href="#🖼️-渲染简图"><span>🖼️ 渲染简图：</span></a></h3><div class="language-txt line-numbers-mode" data-highlighter="shiki" data-ext="txt" data-title="txt" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>component =&gt; setup() =&gt; render() =&gt; vnode =&gt; patch() =&gt; DOM</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><hr><h2 id="_2-异步批量更新机制" tabindex="-1"><a class="header-anchor" href="#_2-异步批量更新机制"><span>2. 异步批量更新机制</span></a></h2><p>Vue 3 采用了<strong>异步批量更新策略</strong>：当响应式数据变化时，组件不会立即重新渲染，而是将更新任务加入一个队列，等待“<strong>下一个宏任务之前</strong>”统一执行。</p><h3 id="📦-为什么需要异步" tabindex="-1"><a class="header-anchor" href="#📦-为什么需要异步"><span>📦 为什么需要异步？</span></a></h3><p>假设你在同一个事件处理函数里修改多个响应式变量，Vue 会收集这些变化，然后 <strong>合并成一个更新任务</strong>，从而避免重复渲染。</p><h3 id="🧪-实现原理简述" tabindex="-1"><a class="header-anchor" href="#🧪-实现原理简述"><span>🧪 实现原理简述</span></a></h3><ol><li>当响应式数据发生变更，<code>effect</code> 会被触发。</li><li><code>scheduler</code> 会将当前更新任务加入 <code>jobQueue</code>。</li><li>Vue 使用 <code>Promise.resolve().then(flushJobs)</code>，在微任务中清空队列。</li></ol><div class="language-ts line-numbers-mode" data-highlighter="shiki" data-ext="ts" data-title="ts" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// effect.ts 内部</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">queueJob</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">instance</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">update</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 代码实现</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#986801;--shiki-dark:#E5C07B;"> queue</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> [];</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">let</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> isFlushing</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> false</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#986801;--shiki-dark:#E5C07B;"> p</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Promise</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">resolve</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">export</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> function</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> queueJob</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">job</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  if</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">!</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">queue</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">includes</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">job</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)) {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">    queue</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">push</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">job</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">); </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 存储当前更新的操作</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // 数据变化更 可能会出现多个组件的更新，所有需要采用队列来存储</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  if</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">!</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">isFlushing</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    isFlushing</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> true</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">; </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 通过批处理来实现的</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">    p</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">then</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(() </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">      isFlushing</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> false</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">      // 这样可确保“刷新的那一批”任务只执行一次，同时原始 queue 可在执行后继续收集下一轮新任务 。</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">      let</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> copyQueue</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> queue</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">slice</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">); </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 将当前要执行的队列拷贝一份，并且清空队列</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">      queue</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">length</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">      copyQueue</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">forEach</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">((</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">job</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">        job</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">      });</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">      copyQueue</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">length</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    });</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 浏览器的事件环、一轮一轮的实现</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="🔂-nexttick-的作用" tabindex="-1"><a class="header-anchor" href="#🔂-nexttick-的作用"><span>🔂 <code>nextTick</code> 的作用？</span></a></h3><p>当你想等待 DOM 更新完成后再执行某个逻辑，可以用 <code>nextTick()</code>：</p><div class="language-ts line-numbers-mode" data-highlighter="shiki" data-ext="ts" data-title="ts" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">await</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> nextTick</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">console</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;DOM 已更新&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><hr><h2 id="_3-组件更新流程" tabindex="-1"><a class="header-anchor" href="#_3-组件更新流程"><span>3. 组件更新流程</span></a></h2><h3 id="✨-属性更新或响应式数据更新会发生什么" tabindex="-1"><a class="header-anchor" href="#✨-属性更新或响应式数据更新会发生什么"><span>✨ 属性更新或响应式数据更新会发生什么？</span></a></h3><p>以父组件传入 <code>props</code> 更新为例：</p><ol><li><p><strong>父组件更新时，patch 调用子组件的 patchComponent。</strong></p></li><li><p>对比前后 props：</p><ul><li>如果有变化，会更新 <code>instance.props</code>；</li><li>然后触发组件的 <code>update</code> 函数。</li></ul></li><li><p><strong>组件会重新执行 render 函数，生成新的 vnode。</strong></p></li><li><p>Vue 使用 <code>patch</code> 对比新旧 vnode，进行最小化的 DOM 操作。</p></li></ol><h3 id="💡-响应式数据更新时" tabindex="-1"><a class="header-anchor" href="#💡-响应式数据更新时"><span>💡 响应式数据更新时：</span></a></h3><ol><li>在 setup 中使用 <code>ref</code> 或 <code>reactive</code> 定义的状态发生变化；</li><li><code>effect</code> 中的依赖会被触发；</li><li>将组件的 <code>update</code> 函数推入更新队列；</li><li>在下一个微任务中重新执行 render + patch。</li></ol><hr><h2 id="🧠-总结-vue-3-组件更新全链路" tabindex="-1"><a class="header-anchor" href="#🧠-总结-vue-3-组件更新全链路"><span>🧠 总结：Vue 3 组件更新全链路</span></a></h2><div class="language-txt line-numbers-mode" data-highlighter="shiki" data-ext="txt" data-title="txt" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>setup() / props 变化 / 响应式数据更新</span></span>
<span class="line"><span>        ↓</span></span>
<span class="line"><span>  触发 reactive 的 effect</span></span>
<span class="line"><span>        ↓</span></span>
<span class="line"><span>  组件实例的 update 被加入更新队列</span></span>
<span class="line"><span>        ↓</span></span>
<span class="line"><span>  等待下一个微任务执行 flushJobs()</span></span>
<span class="line"><span>        ↓</span></span>
<span class="line"><span>  update() 执行 render → vnode</span></span>
<span class="line"><span>        ↓</span></span>
<span class="line"><span>  patch() diff 新旧 vnode → 最小 DOM 操作</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h2 id="✅-小结" tabindex="-1"><a class="header-anchor" href="#✅-小结"><span>✅ 小结</span></a></h2><table><thead><tr><th>模块</th><th>说明</th></tr></thead><tbody><tr><td>渲染流程</td><td>创建实例 → setup → render → patch → mount</td></tr><tr><td>响应式更新机制</td><td>使用 <code>effect</code> 和 <code>scheduler</code> + 微任务队列</td></tr><tr><td>异步渲染策略</td><td>多次更新合并为一次 DOM 更新，提升性能</td></tr><tr><td>DOM Diff 优化</td><td>使用 key 识别 + 最长递增子序列减少节点移动</td></tr></tbody></table><hr>`,36)]))}const k=s(l,[["render",t]]),r=JSON.parse('{"path":"/posts/vue/vue3/%E7%BB%84%E4%BB%B6%E6%9B%B4%E6%96%B0.html","title":"Vue 3 组件的渲染与异步批量更新原理详解","lang":"zh-CN","frontmatter":{"title":"Vue 3 组件的渲染与异步批量更新原理详解","tags":["vue"],"description":"🌟 Vue 3 组件的渲染与异步更新原理详解 Vue 3 在实现细节上有很多重构和优化，特别是在组件渲染流程和异步更新机制方面。本篇文档将围绕以下三个部分展开深入讲解： Vue 3 组件的渲染流程 Vue 3 的异步更新原理（nextTick & 更新队列） 组件更新流程（属性变更、状态响应） 1. 组件的渲染流程 Vue 3 的渲染是基于 Virt...","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/zy-vuepress/posts/vue/vue3/%E7%BB%84%E4%BB%B6%E6%9B%B4%E6%96%B0.html"}],["meta",{"property":"og:site_name","content":"我的基地"}],["meta",{"property":"og:title","content":"Vue 3 组件的渲染与异步批量更新原理详解"}],["meta",{"property":"og:description","content":"🌟 Vue 3 组件的渲染与异步更新原理详解 Vue 3 在实现细节上有很多重构和优化，特别是在组件渲染流程和异步更新机制方面。本篇文档将围绕以下三个部分展开深入讲解： Vue 3 组件的渲染流程 Vue 3 的异步更新原理（nextTick & 更新队列） 组件更新流程（属性变更、状态响应） 1. 组件的渲染流程 Vue 3 的渲染是基于 Virt..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-05-20T07:48:26.000Z"}],["meta",{"property":"article:tag","content":"vue"}],["meta",{"property":"article:modified_time","content":"2025-05-20T07:48:26.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Vue 3 组件的渲染与异步批量更新原理详解\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-05-20T07:48:26.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Mrs.Zoe\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"1. 组件的渲染流程","slug":"_1-组件的渲染流程","link":"#_1-组件的渲染流程","children":[{"level":3,"title":"🧱 初始化渲染流程","slug":"🧱-初始化渲染流程","link":"#🧱-初始化渲染流程","children":[]},{"level":3,"title":"🖼️ 渲染简图：","slug":"🖼️-渲染简图","link":"#🖼️-渲染简图","children":[]}]},{"level":2,"title":"2. 异步批量更新机制","slug":"_2-异步批量更新机制","link":"#_2-异步批量更新机制","children":[{"level":3,"title":"📦 为什么需要异步？","slug":"📦-为什么需要异步","link":"#📦-为什么需要异步","children":[]},{"level":3,"title":"🧪 实现原理简述","slug":"🧪-实现原理简述","link":"#🧪-实现原理简述","children":[]},{"level":3,"title":"🔂 nextTick 的作用？","slug":"🔂-nexttick-的作用","link":"#🔂-nexttick-的作用","children":[]}]},{"level":2,"title":"3. 组件更新流程","slug":"_3-组件更新流程","link":"#_3-组件更新流程","children":[{"level":3,"title":"✨ 属性更新或响应式数据更新会发生什么？","slug":"✨-属性更新或响应式数据更新会发生什么","link":"#✨-属性更新或响应式数据更新会发生什么","children":[]},{"level":3,"title":"💡 响应式数据更新时：","slug":"💡-响应式数据更新时","link":"#💡-响应式数据更新时","children":[]}]},{"level":2,"title":"🧠 总结：Vue 3 组件更新全链路","slug":"🧠-总结-vue-3-组件更新全链路","link":"#🧠-总结-vue-3-组件更新全链路","children":[]},{"level":2,"title":"✅ 小结","slug":"✅-小结","link":"#✅-小结","children":[]}],"git":{"createdTime":1745573689000,"updatedTime":1747727306000,"contributors":[{"name":"zy","username":"zy","email":"891374900@qq.com","commits":4,"url":"https://github.com/zy"},{"name":"zouyu","username":"zouyu","email":"891374900@qq.com","commits":1,"url":"https://github.com/zouyu"}]},"readingTime":{"minutes":3.45,"words":1036},"filePathRelative":"posts/vue/vue3/组件更新.md","localizedDate":"2025年4月25日","excerpt":"<hr>\\n<h1>🌟 Vue 3 组件的渲染与异步更新原理详解</h1>\\n<p>Vue 3 在实现细节上有很多重构和优化，特别是在组件渲染流程和异步更新机制方面。本篇文档将围绕以下三个部分展开深入讲解：</p>\\n<ol>\\n<li><a href=\\"#1-%E7%BB%84%E4%BB%B6%E7%9A%84%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B\\">Vue 3 组件的渲染流程</a></li>\\n<li><a href=\\"#2-%E5%BC%82%E6%AD%A5%E6%9B%B4%E6%96%B0%E6%9C%BA%E5%88%B6\\">Vue 3 的异步更新原理（nextTick &amp; 更新队列）</a></li>\\n<li><a href=\\"#3-%E7%BB%84%E4%BB%B6%E6%9B%B4%E6%96%B0%E6%B5%81%E7%A8%8B\\">组件更新流程（属性变更、状态响应）</a></li>\\n</ol>","autoDesc":true}');export{k as comp,r as data};
