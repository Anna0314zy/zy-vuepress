import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as n,e as a,o as t}from"./app-D4yN_ylH.js";const l={};function e(h,i){return t(),n("div",null,i[0]||(i[0]=[a(`<hr><h2 id="🏗-整体架构" tabindex="-1"><a class="header-anchor" href="#🏗-整体架构"><span>🏗 整体架构</span></a></h2><ol><li><p><strong>主应用 (基座应用)</strong></p><ul><li>负责路由控制、子应用加载/卸载、公共依赖管理。</li><li>通过 qiankun 注册子应用，监听路由变化决定加载哪个子应用。</li></ul></li><li><p><strong>子应用</strong></p><ul><li>每个子应用本质上还是一个独立的 SPA（Vue、React、Angular 都可以）。</li><li>打包时必须暴露三个生命周期：<code>bootstrap</code>、<code>mount</code>、<code>unmount</code>，供 qiankun 调用。</li></ul></li></ol><hr><h2 id="🔑-核心原理" tabindex="-1"><a class="header-anchor" href="#🔑-核心原理"><span>🔑 核心原理</span></a></h2><h3 id="_1-路由劫持" tabindex="-1"><a class="header-anchor" href="#_1-路由劫持"><span>1. <strong>路由劫持</strong></span></a></h3><p>qiankun 需要知道<strong>什么时候切换子应用</strong>。</p><ul><li>内部会<strong>重写 <code>history.pushState</code> 和 <code>replaceState</code></strong>，并监听 <code>popstate</code>、<code>hashchange</code> 事件。</li><li>当路由变化时，对比注册的规则（<code>activeRule</code>），决定加载/卸载哪个子应用。</li></ul><p>👉 类似于 React Router 监听 URL 的原理，但 qiankun 是在框架层做的。</p><hr><h3 id="_2-子应用加载" tabindex="-1"><a class="header-anchor" href="#_2-子应用加载"><span>2. <strong>子应用加载</strong></span></a></h3><p>子应用并不是预先打包到主应用里，而是运行时按需加载：</p><ul><li>主应用通过 <code>fetch</code> 拉取子应用的 <code>entry</code>（通常是一个 <code>index.html</code>）。</li><li>解析 HTML，提取出 <strong>JS、CSS</strong>。</li><li>把子应用的资源插入到 DOM 中。</li></ul><p>qiankun 做了一层 <strong>import-html-entry</strong>：</p><ul><li>处理 <code>&lt;script&gt;</code>、<code>&lt;link&gt;</code> 标签，保证子应用能独立运行。</li><li>资源加载支持<strong>缓存、预加载</strong>，提升性能。</li></ul><hr><h3 id="_3-js-隔离-沙箱机制" tabindex="-1"><a class="header-anchor" href="#_3-js-隔离-沙箱机制"><span>3. <strong>JS 隔离（沙箱机制）</strong></span></a></h3><p>防止子应用之间全局变量污染。<br> qiankun 提供了几种沙箱实现：</p><ul><li><p><strong>快照沙箱</strong>（SnapshotSandbox）：</p><ul><li>激活子应用前，保存 <code>window</code> 上的全局变量快照；</li><li>卸载时恢复快照。</li><li>缺点：性能差（大对象复制）。</li></ul></li><li><p><strong>Proxy 沙箱</strong>（默认，现代浏览器支持）：</p><ul><li>用 <code>Proxy(window)</code> 创建一个代理对象，让子应用的全局访问都指向这个代理。</li><li>这样子应用里的 <code>window.xxx = ...</code> 不会污染主应用。</li></ul></li><li><p><strong>LegacySandbox</strong>：兼容性方案，专门给 IE 用的。</p></li></ul><hr><h3 id="_4-css-隔离" tabindex="-1"><a class="header-anchor" href="#_4-css-隔离"><span>4. <strong>CSS 隔离</strong></span></a></h3><ul><li><strong>样式作用域隔离</strong>：qiankun 会给子应用根节点加一个特定的 <code>container</code>，样式不会溢出。</li><li><strong>样式沙箱</strong>：可选，使用 <code>shadow DOM</code> 或 <code>CSS Scoped</code> 的方式进一步隔离。</li><li><strong>样式隔离插件</strong>：通过动态样式表（<code>styleLoader</code>）管理，子应用卸载时自动清理。</li></ul><hr><h3 id="_5-应用通信" tabindex="-1"><a class="header-anchor" href="#_5-应用通信"><span>5. <strong>应用通信</strong></span></a></h3><p>qiankun 提供了一个 <code>initGlobalState</code> 方法，主/子应用之间可以共享状态。</p><div class="language-ts line-numbers-mode" data-highlighter="shiki" data-ext="ts" data-title="ts" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 主应用</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#986801;--shiki-dark:#E5C07B;"> actions</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> initGlobalState</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">({ </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">user</span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &#39;Tom&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> });</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">actions</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">onGlobalStateChange</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">((</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">state</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">prev</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> { </span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;">...</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> });</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">actions</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">setGlobalState</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">({ </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">user</span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &#39;Jerry&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> });</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 子应用</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">import</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> { </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">MicroAppStateActions</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> } </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">from</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &#39;qiankun&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">let</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> actions</span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> MicroAppStateActions</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">export</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> function</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> mount</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">props</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">  actions</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> props</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">actions</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">  actions</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">onGlobalStateChange</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">((</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">state</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> console</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">state</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">));</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>原理很简单：就是一个全局的事件中心（发布订阅模式）。</p><hr><h3 id="_6-生命周期管理" tabindex="-1"><a class="header-anchor" href="#_6-生命周期管理"><span>6. <strong>生命周期管理</strong></span></a></h3><p>每个子应用必须导出：</p><div class="language-js line-numbers-mode" data-highlighter="shiki" data-ext="js" data-title="js" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">export</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> async</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> function</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> bootstrap</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">() {}</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">export</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> async</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> function</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> mount</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">props</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {}</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">export</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> async</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> function</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> unmount</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">props</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>qiankun 在合适的时机调用这些钩子：</p><ul><li><strong>bootstrap</strong>：第一次加载子应用时调用（只调用一次）。</li><li><strong>mount</strong>：每次进入子应用路由时调用。</li><li><strong>unmount</strong>：离开子应用时调用。</li></ul><hr><h2 id="🧩-总结流程" tabindex="-1"><a class="header-anchor" href="#🧩-总结流程"><span>🧩 总结流程</span></a></h2><ol><li>主应用注册子应用（配置 <code>name</code>, <code>entry</code>, <code>container</code>, <code>activeRule</code>）。</li><li>qiankun 劫持路由，匹配到子应用 → fetch 资源。</li><li>解析子应用 HTML，注入 JS、CSS。</li><li>JS 运行在沙箱里，CSS 作用域隔离。</li><li>调用子应用的 <code>bootstrap</code> → <code>mount</code>。</li><li>切换路由时，调用 <code>unmount</code>，卸载子应用。</li></ol><hr><h2 id="🚀-关键价值" tabindex="-1"><a class="header-anchor" href="#🚀-关键价值"><span>🚀 关键价值</span></a></h2><ul><li><strong>技术栈无关</strong>：React、Vue、Angular 子应用可共存。</li><li><strong>运行时加载</strong>：子应用独立部署、按需加载。</li><li><strong>隔离</strong>：JS、CSS 隔离，避免互相污染。</li><li><strong>通信</strong>：提供简单的全局状态共享。</li></ul>`,39)]))}const k=s(l,[["render",e]]),o=JSON.parse('{"path":"/posts/%E5%BE%AE%E5%89%8D%E7%AB%AF/qiankun.html","title":"qiankun","lang":"zh-CN","frontmatter":{"title":"qiankun","tags":["微前端"],"description":"🏗 整体架构 主应用 (基座应用) 负责路由控制、子应用加载/卸载、公共依赖管理。 通过 qiankun 注册子应用，监听路由变化决定加载哪个子应用。 子应用 每个子应用本质上还是一个独立的 SPA（Vue、React、Angular 都可以）。 打包时必须暴露三个生命周期：bootstrap、mount、unmount，供 qiankun 调用。 ...","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/zy-vuepress/posts/%E5%BE%AE%E5%89%8D%E7%AB%AF/qiankun.html"}],["meta",{"property":"og:site_name","content":"我的基地"}],["meta",{"property":"og:title","content":"qiankun"}],["meta",{"property":"og:description","content":"🏗 整体架构 主应用 (基座应用) 负责路由控制、子应用加载/卸载、公共依赖管理。 通过 qiankun 注册子应用，监听路由变化决定加载哪个子应用。 子应用 每个子应用本质上还是一个独立的 SPA（Vue、React、Angular 都可以）。 打包时必须暴露三个生命周期：bootstrap、mount、unmount，供 qiankun 调用。 ..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-09-04T03:16:50.000Z"}],["meta",{"property":"article:tag","content":"微前端"}],["meta",{"property":"article:modified_time","content":"2025-09-04T03:16:50.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"qiankun\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-09-04T03:16:50.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Mrs.Zoe\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"🏗 整体架构","slug":"🏗-整体架构","link":"#🏗-整体架构","children":[]},{"level":2,"title":"🔑 核心原理","slug":"🔑-核心原理","link":"#🔑-核心原理","children":[{"level":3,"title":"1. 路由劫持","slug":"_1-路由劫持","link":"#_1-路由劫持","children":[]},{"level":3,"title":"2. 子应用加载","slug":"_2-子应用加载","link":"#_2-子应用加载","children":[]},{"level":3,"title":"3. JS 隔离（沙箱机制）","slug":"_3-js-隔离-沙箱机制","link":"#_3-js-隔离-沙箱机制","children":[]},{"level":3,"title":"4. CSS 隔离","slug":"_4-css-隔离","link":"#_4-css-隔离","children":[]},{"level":3,"title":"5. 应用通信","slug":"_5-应用通信","link":"#_5-应用通信","children":[]},{"level":3,"title":"6. 生命周期管理","slug":"_6-生命周期管理","link":"#_6-生命周期管理","children":[]}]},{"level":2,"title":"🧩 总结流程","slug":"🧩-总结流程","link":"#🧩-总结流程","children":[]},{"level":2,"title":"🚀 关键价值","slug":"🚀-关键价值","link":"#🚀-关键价值","children":[]}],"git":{"createdTime":1756955810000,"updatedTime":1756955810000,"contributors":[{"name":"zouyu","username":"zouyu","email":"891374900@qq.com","commits":1,"url":"https://github.com/zouyu"}]},"readingTime":{"minutes":2.76,"words":827},"filePathRelative":"posts/微前端/qiankun.md","localizedDate":"2025年9月4日","excerpt":"<hr>\\n<h2>🏗 整体架构</h2>\\n<ol>\\n<li>\\n<p><strong>主应用 (基座应用)</strong></p>\\n<ul>\\n<li>负责路由控制、子应用加载/卸载、公共依赖管理。</li>\\n<li>通过 qiankun 注册子应用，监听路由变化决定加载哪个子应用。</li>\\n</ul>\\n</li>\\n<li>\\n<p><strong>子应用</strong></p>\\n<ul>\\n<li>每个子应用本质上还是一个独立的 SPA（Vue、React、Angular 都可以）。</li>\\n<li>打包时必须暴露三个生命周期：<code>bootstrap</code>、<code>mount</code>、<code>unmount</code>，供 qiankun 调用。</li>\\n</ul>\\n</li>\\n</ol>","autoDesc":true}');export{k as comp,o as data};
