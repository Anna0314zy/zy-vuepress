import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as e,e as a,o as n}from"./app-DkVa7Hgi.js";const t={};function l(o,s){return n(),e("div",null,s[0]||(s[0]=[a(`<h2 id="参考" tabindex="-1"><a class="header-anchor" href="#参考"><span>参考</span></a></h2><ul><li><a href="https://juejin.cn/post/7181720787400228925" target="_blank" rel="noopener noreferrer">pnpm + monorepo + changeset实现多包管理和发布</a></li></ul><h2 id="turborepo" tabindex="-1"><a class="header-anchor" href="#turborepo"><span>Turborepo</span></a></h2><p>子包 libs/component ，但是下次 libs/component 没有代码改动，如何跳过这部分前置依赖的构建？</p><p>此时推荐你使用 <a href="https://turborepo.com/docs" target="_blank" rel="noopener noreferrer">Turborepo</a> 来做 monorepo 构建方案，具体使用方法请参见 官方文档 和 examples 。</p><p>注：如果在 CI 中构建，同样需要容器支持恢复上次的 turbo 缓存，可以通过 --cache-dir 选项更改缓存位置。</p><hr><h1 id="monorepo-多包仓库-里子包依赖管理机制" tabindex="-1"><a class="header-anchor" href="#monorepo-多包仓库-里子包依赖管理机制"><span>monorepo（多包仓库）里子包依赖管理机制</span></a></h1><h1 id="_1️⃣-monorepo-结构示例" tabindex="-1"><a class="header-anchor" href="#_1️⃣-monorepo-结构示例"><span>1️⃣ Monorepo 结构示例</span></a></h1><p>假设项目结构如下：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>my-monorepo/</span></span>
<span class="line"><span>├─ package.json            &lt;- 根 package.json</span></span>
<span class="line"><span>├─ pnpm-workspace.yaml     &lt;- workspace 配置</span></span>
<span class="line"><span>├─ node_modules/           &lt;- 根 node_modules</span></span>
<span class="line"><span>├─ apps/</span></span>
<span class="line"><span>│  ├─ react_editor/</span></span>
<span class="line"><span>│  │   └─ package.json</span></span>
<span class="line"><span>│  └─ editor/</span></span>
<span class="line"><span>│     └─ package.json</span></span>
<span class="line"><span>└─ packages/</span></span>
<span class="line"><span>   ├─ class-bridge/</span></span>
<span class="line"><span>   │   └─ package.json</span></span>
<span class="line"><span>   └─ game-sdk/</span></span>
<span class="line"><span>       └─ package.json</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><strong>apps/</strong>：前端应用</li><li><strong>packages/</strong>：共享库</li><li><strong>根 package.json</strong>：全局依赖、工具依赖（vite, typescript, eslint…）</li></ul><hr><h1 id="_2️⃣-子包依赖管理规则" tabindex="-1"><a class="header-anchor" href="#_2️⃣-子包依赖管理规则"><span>2️⃣ 子包依赖管理规则</span></a></h1><h3 id="_2-1-声明依赖" tabindex="-1"><a class="header-anchor" href="#_2-1-声明依赖"><span>2.1 声明依赖</span></a></h3><ul><li><strong>子包自己的依赖</strong>：写在 <code>apps/react_editor/package.json</code> 或 <code>packages/game-sdk/package.json</code></li><li><strong>全局工具依赖</strong>：可以放在根 package.json，例如 vite、typescript</li><li><strong>共享库依赖</strong>：放在 packages 下的子包 package.json</li></ul><hr><h3 id="_2-2-安装机制-pnpm-默认-hoist" tabindex="-1"><a class="header-anchor" href="#_2-2-安装机制-pnpm-默认-hoist"><span>2.2 安装机制（pnpm 默认 hoist）</span></a></h3><ol><li>根目录执行 <code>pnpm install</code></li><li>pnpm 会遍历所有 workspace 子包</li><li>所有依赖尽量 <strong>安装到根 node_modules</strong>（hoist）</li><li>子包的 node_modules 通常是空的（除非你设置 isolated linker）</li><li>依赖解析规则：</li></ol><ul><li><strong>子包依赖</strong> → 子包 package.json 声明的依赖</li><li><strong>全局依赖 / hoisted</strong> → 根 node_modules 可以被所有子包共享</li><li><strong>子包之间依赖</strong> → workspace 内部引用时，可以直接 import（pnpm 自动链接）</li></ul><hr><h1 id="_3️⃣-子包之间的依赖" tabindex="-1"><a class="header-anchor" href="#_3️⃣-子包之间的依赖"><span>3️⃣ 子包之间的依赖</span></a></h1><p>假设 <code>apps/react_editor</code> 依赖 <code>packages/game-sdk</code>：</p><div class="language-json line-numbers-mode" data-highlighter="shiki" data-ext="json" data-title="json" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// apps/react_editor/package.json</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">{</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">  &quot;dependencies&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: {</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">    &quot;game-sdk&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;workspace:*&quot;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><code>&quot;workspace:*&quot;</code> → 表示依赖 <strong>monorepo 内的子包</strong></li><li>pnpm 会 <strong>建立 symlink</strong>，把 <code>node_modules/game-sdk</code> 链接到 <code>packages/game-sdk</code></li><li><strong>本地开发时修改 packages/game-sdk 会立即反映在 react_editor</strong></li><li>安装命令仍然在根目录执行：</li></ul><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" data-title="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">pnpm</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> install</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><hr><h1 id="_4️⃣-查找依赖的方式" tabindex="-1"><a class="header-anchor" href="#_4️⃣-查找依赖的方式"><span>4️⃣ 查找依赖的方式</span></a></h1><h3 id="_4-1-全局依赖" tabindex="-1"><a class="header-anchor" href="#_4-1-全局依赖"><span>4.1 全局依赖</span></a></h3><ul><li>根 node_modules 里的依赖</li><li>子包可以直接引用，例如 vite、typescript</li></ul><div class="language-ts line-numbers-mode" data-highlighter="shiki" data-ext="ts" data-title="ts" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// apps/react_editor/src/main.tsx</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">import</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> React</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> from</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;react&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;   </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 根 node_modules/react</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">import</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> { </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">Button</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> } </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">from</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;@stars/class-bridge&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;  </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// workspace 子包</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_4-2-子包依赖" tabindex="-1"><a class="header-anchor" href="#_4-2-子包依赖"><span>4.2 子包依赖</span></a></h3><ul><li>workspace 内部子包，通过 <strong>workspace:</strong>* 或具体版本声明</li><li>pnpm 会创建 symlink，让子包能直接 import</li></ul><div class="language-ts line-numbers-mode" data-highlighter="shiki" data-ext="ts" data-title="ts" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">import</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> { </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">initBridge</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> } </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">from</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;class-bridge&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;  </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// class-bridge 来自 packages/class-bridge</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li>这个依赖不需要发布到 npm 就可以被其他子包使用</li><li>pnpm 会在根 node_modules 中建立指向 packages 的软链接</li></ul><hr><h1 id="_5️⃣-依赖解析规则-从内到外" tabindex="-1"><a class="header-anchor" href="#_5️⃣-依赖解析规则-从内到外"><span>5️⃣ 依赖解析规则（从内到外）</span></a></h1><ol><li><strong>子包自己声明的依赖</strong> → 首先查找本地 node_modules（如果 isolated）</li><li><strong>hoisted 依赖</strong> → 根 node_modules</li><li><strong>workspace symlink</strong> → 内部包</li><li><strong>node_modules 查找顺序</strong> → 符合 Node.js 模块解析机制</li></ol><hr><h1 id="_6️⃣-优点" tabindex="-1"><a class="header-anchor" href="#_6️⃣-优点"><span>6️⃣ 优点</span></a></h1><ol><li><strong>统一版本管理</strong> → 避免多个版本冲突</li><li><strong>共享 node_modules</strong> → 节省磁盘空间</li><li><strong>子包开发即时可用</strong> → 修改共享库，应用立即生效</li><li><strong>可以单独发布或整体管理</strong> → 灵活</li></ol><hr><h1 id="_7️⃣-小结" tabindex="-1"><a class="header-anchor" href="#_7️⃣-小结"><span>7️⃣ 小结</span></a></h1><table><thead><tr><th>类型</th><th>放置位置</th><th>安装方式</th><th>访问方式</th></tr></thead><tbody><tr><td>根工具依赖</td><td>根 package.json</td><td>根目录 pnpm install</td><td>子包直接 import</td></tr><tr><td>子包自身依赖</td><td>子包 package.json</td><td>根目录 pnpm install</td><td>子包 import</td></tr><tr><td>子包间依赖</td><td>workspace 子包 package.json</td><td>root pnpm install + workspace:*</td><td>symlink + import</td></tr><tr><td>外部 npm 库</td><td>子包或根 package.json</td><td>pnpm install</td><td>子包 import</td></tr></tbody></table><blockquote><p>⚠️ <strong>关键点</strong>：pnpm workspace 会把依赖 hoist 到根目录，同时内部子包通过 symlink 互相引用，这就是 monorepo 的核心管理机制。</p></blockquote>`,45)]))}const d=i(t,[["render",l]]),h=JSON.parse('{"path":"/posts/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/monorepo.html","title":"monorepo","lang":"zh-CN","frontmatter":{"title":"monorepo","tags":["工程化"],"description":"参考 pnpm + monorepo + changeset实现多包管理和发布 Turborepo 子包 libs/component ，但是下次 libs/component 没有代码改动，如何跳过这部分前置依赖的构建？ 此时推荐你使用 Turborepo 来做 monorepo 构建方案，具体使用方法请参见 官方文档 和 examples 。 注：...","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/zy-vuepress/posts/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/monorepo.html"}],["meta",{"property":"og:site_name","content":"我的基地"}],["meta",{"property":"og:title","content":"monorepo"}],["meta",{"property":"og:description","content":"参考 pnpm + monorepo + changeset实现多包管理和发布 Turborepo 子包 libs/component ，但是下次 libs/component 没有代码改动，如何跳过这部分前置依赖的构建？ 此时推荐你使用 Turborepo 来做 monorepo 构建方案，具体使用方法请参见 官方文档 和 examples 。 注：..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-11-19T08:07:06.000Z"}],["meta",{"property":"article:tag","content":"工程化"}],["meta",{"property":"article:modified_time","content":"2025-11-19T08:07:06.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"monorepo\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-11-19T08:07:06.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Mrs.Zoe\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"参考","slug":"参考","link":"#参考","children":[]},{"level":2,"title":"Turborepo","slug":"turborepo","link":"#turborepo","children":[{"level":3,"title":"2.1 声明依赖","slug":"_2-1-声明依赖","link":"#_2-1-声明依赖","children":[]},{"level":3,"title":"2.2 安装机制（pnpm 默认 hoist）","slug":"_2-2-安装机制-pnpm-默认-hoist","link":"#_2-2-安装机制-pnpm-默认-hoist","children":[]},{"level":3,"title":"4.1 全局依赖","slug":"_4-1-全局依赖","link":"#_4-1-全局依赖","children":[]},{"level":3,"title":"4.2 子包依赖","slug":"_4-2-子包依赖","link":"#_4-2-子包依赖","children":[]}]}],"git":{"createdTime":1742297446000,"updatedTime":1763539626000,"contributors":[{"name":"zy","username":"zy","email":"891374900@qq.com","commits":4,"url":"https://github.com/zy"},{"name":"zouyu","username":"zouyu","email":"891374900@qq.com","commits":2,"url":"https://github.com/zouyu"}]},"readingTime":{"minutes":2.71,"words":812},"filePathRelative":"posts/前端工程化/monorepo.md","localizedDate":"2025年3月18日","excerpt":"<h2>参考</h2>\\n<ul>\\n<li><a href=\\"https://juejin.cn/post/7181720787400228925\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">pnpm + monorepo + changeset实现多包管理和发布</a></li>\\n</ul>\\n<h2>Turborepo</h2>\\n<p>子包 libs/component ，但是下次 libs/component 没有代码改动，如何跳过这部分前置依赖的构建？</p>\\n<p>此时推荐你使用 <a href=\\"https://turborepo.com/docs\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">Turborepo</a> 来做 monorepo 构建方案，具体使用方法请参见 官方文档 和 examples 。</p>","autoDesc":true}');export{d as comp,h as data};
