---
title: Vue 3 批量更新
tags:
  - vue
---


---

Vue3 的 **批量更新（Batched Updates）** 机制是其性能优化的重要部分，核心思想是 **将多个同步的数据变更合并为一次更新**，避免频繁触发 DOM 渲染。以下是其实现原理和关键步骤：

---

### **1. 核心设计思想**
- **减少重复渲染**：  
  在同一事件循环（Event Loop）中，无论多少次同步的数据修改，Vue3 会将所有变更合并为一次组件更新。
- **基于调度器的异步队列**：  
  通过 **微任务（Microtask）** 延迟更新执行，利用 JavaScript 的事件循环机制实现批量处理。

---

### **2. 实现流程**
#### **(1) 响应式数据变更触发更新**
当修改响应式数据（如 `ref` 或 `reactive` 对象）时，会触发依赖该数据的 **副作用（Effect）**，例如组件的重新渲染。

#### **(2) 将 Effect 推入队列**
- Vue3 通过 **调度器（scheduler）** 管理 Effect 的执行：  
  每次数据变更触发的 Effect 会被放入一个 **异步队列（queue）**，而非立即执行。
- **去重处理**：  
  同一 Effect 在同一个队列中只会被添加一次，避免重复更新。

```javascript
// 伪代码示例：调度器逻辑
const queue = new Set();
let isFlushing = false;

function queueJob(job) {
  queue.add(job);
  if (!isFlushing) {
    isFlushing = true;
    Promise.resolve().then(() => {
      try {
        queue.forEach(job => job());
      } finally {
        queue.clear();
        isFlushing = false;
      }
    });
  }
}
```

#### **(3) 在微任务中批量执行**
- **异步执行时机**：  
  队列中的 Effect 会在当前同步代码执行完毕后，通过 `Promise.resolve().then()` 在 **微任务阶段** 统一执行。
- **合并更新**：  
  所有同步的数据变更触发的 Effect 会被合并为一次 DOM 更新。

---

### **3. 示例场景**
假设在一个事件循环中连续修改多个响应式数据：
```javascript
import { ref } from 'vue';

const count = ref(0);
const name = ref('Vue3');

// 同步修改数据
count.value++;
name.value = 'Batched Update';
count.value++;
```
- **执行过程**：  
  1. 三次数据变更触发三次 Effect（组件更新）。  
  2. 所有 Effect 被推入队列并去重（同一组件的更新只需一次）。  
  3. 微任务阶段执行队列中的 Effect，触发一次 DOM 更新。

---

### **4. 关键技术点**
#### **(1) 异步队列与微任务**
- **微任务优先级**：  
  使用 `Promise.then` 或 `queueMicrotask` 将更新推迟到微任务队列，确保在当前宏任务（如点击事件、定时器）结束后立即执行。
- **避免 UI 阻塞**：  
  微任务在浏览器渲染前执行，减少帧丢失的可能性。

#### **(2) 调度器（Scheduler）**
- **控制更新时机**：  
  在创建 Effect 时，可通过 `scheduler` 参数自定义调度逻辑（如 `watchEffect` 或组件渲染的调度）。
- **Vue3 内置调度器**：  
  组件的更新任务默认使用异步队列调度。

---

### **5. 对比 Vue2 的更新机制**
| **特性**         | **Vue2**                      | **Vue3**                      |
|------------------|-------------------------------|-------------------------------|
| **异步队列**     | 使用 `setTimeout(fn, 0)`（宏任务） | 使用 `Promise.then`（微任务） |
| **执行时机**     | 下一次事件循环的宏任务阶段     | 当前事件循环的微任务阶段       |
| **更新延迟**     | 可能延迟到下一帧渲染后         | 更早执行，减少渲染延迟         |
| **批量更新范围** | 同一事件循环内的同步操作       | 同一事件循环内的同步操作       |

---

### **6. 手动控制更新**
#### **(1) `nextTick` 方法**
- 在数据变更后，通过 `nextTick` 等待 DOM 更新完成：  
  ```javascript
  import { nextTick } from 'vue';

  async function updateData() {
    count.value++;
    await nextTick();
    console.log('DOM 已更新');
  }
  ```

#### **(2) 同步强制更新（慎用）**
- 通过 `flush: 'sync'` 强制立即更新（破坏批量优化）：  
  ```javascript
  watchEffect(() => {
    console.log(count.value);
  }, { flush: 'sync' }); // 同步执行
  ```

---

### **7. 总结**
Vue3 的批量更新机制通过 **异步队列 + 微任务调度** 实现，核心优势在于：
1. **减少 DOM 操作次数**：合并同一事件循环内的数据变更。  
2. **更快的渲染时机**：微任务比宏任务更早执行，减少用户感知的延迟。  
3. **自动去重优化**：避免同一组件的重复更新。  

这一机制使得 Vue3 在高频率数据变更场景下（如动画、实时输入）依然保持高效渲染。