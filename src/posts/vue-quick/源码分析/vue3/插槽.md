---
title: Vue 3 插槽
tags:
  - vue
---


Vue3 的插槽（Slots）机制是其组件化设计的核心功能之一，它通过 **编译时优化** 和 **运行时动态渲染** 实现高效的父子组件内容分发。以下是其核心原理和实现细节：

---

### 一、**插槽的本质：编译时的内容分发**
Vue3 的插槽并非简单的 DOM 替换，而是 **将父组件的模板内容编译为子组件可执行的渲染函数**，实现作用域隔离和动态更新。关键流程如下：

---

### 二、**插槽的编译阶段**
#### 1. **父组件模板编译**
假设父组件使用插槽：
```html
<!-- Parent.vue -->
<Child>
  <template #default="{ data }">
    <div>{{ data }}</div>
  </template>
</Child>
```
- **编译结果**：  
  父组件的插槽内容会被编译为一个 **插槽函数（slot function）**，存储在子组件的 `$slots` 或 `$scopedSlots` 中（Vue3 中统一为 `slots` 对象）。
- **生成代码示例**：
  ```javascript
  // 父组件渲染函数伪代码
  const parentRender = () => {
    return h(Child, {}, {
      default: (props) => [h('div', props.data)] // 插槽内容转为函数
    });
  };
  ```

#### 2. **子组件模板编译**
子组件内部定义插槽：
```html
<!-- Child.vue -->
<template>
  <div>
    <slot :data="childData"></slot>
  </div>
</template>
```
- **编译结果**：  
  子组件的 `<slot>` 标签会被替换为 **调用插槽函数**，并传入子组件的作用域数据。
- **生成代码示例**：
  ```javascript
  // 子组件渲染函数伪代码
  const childRender = (ctx) => {
    return h('div', {}, 
      ctx.$slots.default({ data: ctx.childData }) // 执行插槽函数并传入子组件数据
    );
  };
  ```

---

### 三、**运行时渲染流程**
#### 1. **插槽内容存储**
- **普通插槽（静态内容）**：  
  在父组件渲染时，插槽内容会被提前编译并缓存在子组件的 `slots` 对象中。
- **作用域插槽（动态内容）**：  
  插槽内容以函数形式存在，子组件渲染时通过执行函数获取最新内容。

#### 2. **作用域隔离**
- **数据流向**：  
  父组件的插槽函数可以访问父组件的作用域，而子组件通过调用插槽函数并传入自身数据（如 `:data="childData"`），实现 **子→父的数据传递**。
- **无反向数据流**：  
  插槽内容无法直接修改子组件数据，保持单向数据流。

#### 3. **动态更新机制**
- **依赖追踪**：  
  若插槽内容依赖响应式数据（如父组件的 `data` 或子组件的 `childData`），Vue3 会自动建立依赖关系。
- **精准更新**：  
  当子组件传递的数据变化时，仅重新执行插槽函数并更新对应的 DOM 部分，避免全量渲染。

---

### 四、**Vue3 插槽的核心优化**
#### 1. **插槽内容编译为函数**
- **Vue2 的问题**：  
  插槽内容作为静态 VNode 存储在父组件中，子组件数据变化时需全量重新渲染。
- **Vue3 的优化**：  
  插槽内容编译为函数，子组件数据变化时仅重新执行函数生成新的 VNode，结合 Patch Flags 实现局部更新。

#### 2. **静态提升（Static Hoisting）**
- **静态插槽内容优化**：  
  如果插槽内容无动态绑定（如纯文本），Vue3 会将其提升为静态节点，跳过重复渲染。

#### 3. **Fragment 支持**
- **多根节点插槽**：  
  Vue3 支持插槽返回多个根节点（使用 Fragment），无需外层包裹 `<div>`。

---

### 五、**插槽类型与实现差异**
#### 1. **默认插槽**
- **编译结果**：  
  父组件的默认内容映射到 `slots.default`。
- **子组件调用**：  
  `slots.default()` 执行插槽函数。

#### 2. **具名插槽**
```html
<!-- 父组件 -->
<template #header>
  <h1>标题</h1>
</template>

<!-- 子组件 -->
<slot name="header"></slot>
```
- **编译结果**：  
  父组件的具名插槽存储在 `slots.header` 中。
- **子组件调用**：  
  `slots.header()`。

#### 3. **作用域插槽**
```html
<!-- 父组件 -->
<template #item="{ value }">
  <span>{{ value }}</span>
</template>

<!-- 子组件 -->
<slot name="item" :value="itemValue"></slot>
```
- **数据传递**：  
  子组件通过函数参数传递数据（如 `:value="itemValue"`），父组件通过解构接收。

---

### 六、**性能对比（Vue3 vs Vue2）**
| **特性**         | **Vue2**                              | **Vue3**                              |
|------------------|---------------------------------------|---------------------------------------|
| **插槽内容存储** | 静态 VNode 数组                       | 动态函数（按需生成 VNode）             |
| **更新范围**     | 子组件数据变化时全量更新插槽          | 仅重新执行插槽函数，局部更新           |
| **作用域隔离**   | 通过 `scopeId` 实现样式隔离           | 天然函数作用域隔离                     |
| **内存占用**     | 缓存所有插槽 VNode，内存消耗较高      | 按需生成 VNode，内存更优化             |

---

### 七、**示例：插槽的运行时结果**
#### 父组件模板：
```html
<Child>
  <template #content="{ message }">
    <p>{{ message }}</p>
  </template>
</Child>
```

#### 子组件模板：
```html
<slot name="content" :message="childMessage"></slot>
```

#### 编译后的伪代码：
```javascript
// 父组件渲染函数
h(Child, {}, {
  content: ({ message }) => h('p', message)
});

// 子组件渲染函数
h('div', {}, slots.content({ message: 'Hello from child' }));
```

---

### 八、**总结**
Vue3 的插槽机制通过以下设计实现高效内容分发：
1. **编译时函数化**：将插槽内容编译为函数，实现作用域隔离和按需渲染。  
2. **动态数据传递**：子组件通过函数参数向父组件插槽传递数据，保持单向数据流。  
3. **精准更新**：结合响应式系统和 Patch Flags，仅更新变化的插槽部分。  
4. **静态优化**：对静态插槽内容进行提升，减少运行时开销。  

这种设计使得 Vue3 的插槽在复杂场景下（如列表渲染、动态插槽名）仍能保持高性能，同时提供更灵活的组件复用能力。