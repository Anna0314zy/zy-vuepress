---
title: 强缓存与协商缓存
tags:
  - Javascript
  - 面试题
---

下面是一篇详细阐述 HTTP 协商缓存和强缓存的文章，包含概念介绍、原理解析以及示例代码，帮助你深入理解这两种缓存机制的作用和区别。

---

# HTTP 缓存机制：强缓存与协商缓存

在 Web 开发中，HTTP 缓存机制用于减少客户端与服务器之间的数据传输，提高页面加载速度和用户体验。HTTP 缓存主要分为两大类：**强缓存**和**协商缓存**。本文将详细介绍这两种缓存机制的原理、使用场景及其实现方式。

---

## 一、强缓存（Fresh Cache）

### 1.1 概念

**强缓存**（又称“绝对缓存”）指的是浏览器在缓存有效期内直接使用本地缓存资源，而不向服务器发起请求。这种方式能大大加快页面加载速度，因为资源不需要重新下载。

### 1.2 主要响应头

- **Expires**  
  指定资源过期的绝对时间。示例：
  ```http
  Expires: Wed, 21 Oct 2025 07:28:00 GMT
  ```
  浏览器会比较当前时间和 Expires 值，如果当前时间早于 Expires，则直接使用缓存。

- **Cache-Control**  
  更灵活的缓存控制方式，常用的指令包括：
  - `max-age`：资源在缓存中的有效期（单位为秒）。
  - `public` / `private`：指定资源可否被中间缓存服务器缓存。
  - `no-cache` / `no-store`：指示不使用缓存或不存储缓存。
  
  示例：
  ```http
  Cache-Control: max-age=3600, public
  ```
  这表示资源在 3600 秒内有效，且可以被共享缓存存储。

### 1.3 优点与缺点

**优点：**
- 响应速度快，完全由本地缓存读取资源，无网络请求。
- 减轻服务器负载，节省带宽。

**缺点：**
- 更新不及时：如果资源更新但缓存未过期，用户可能会看到旧资源。
- 配置不当可能导致缓存污染或安全问题。

---

## 二、协商缓存（Conditional Request Cache）

### 2.1 概念

**协商缓存**是在浏览器缓存失效后，通过与服务器进行条件性请求来判断资源是否发生变化。如果资源未更新，服务器返回 304 状态码，告知浏览器继续使用缓存；否则返回新的资源内容。协商缓存虽然需要发起请求，但传输数据量极小（仅返回 304 响应头），因此依然能提升性能。

### 2.2 主要响应头与请求头

- **Last-Modified / If-Modified-Since**

  - **Last-Modified**：服务器响应头，表示资源最后一次修改时间。
    
    示例：
    ```http
    Last-Modified: Wed, 21 Oct 2020 07:28:00 GMT
    ```
    
  - **If-Modified-Since**：浏览器请求头，携带上次缓存的修改时间，服务器比较后决定是否返回新资源。
    
    示例：
    ```http
    If-Modified-Since: Wed, 21 Oct 2020 07:28:00 GMT
    ```

- **ETag / If-None-Match**

  - **ETag**：服务器响应头，为资源生成的唯一标识（通常基于内容哈希）。
    
    示例：
    ```http
    ETag: "5d8c72a5edda3e7a-1"
    ```
    
  - **If-None-Match**：浏览器请求头，携带上次缓存的 ETag，服务器比较后决定是否返回新资源。
    
    示例：
    ```http
    If-None-Match: "5d8c72a5edda3e7a-1"
    ```

### 2.3 协商缓存流程

1. **首次请求**  
   浏览器请求资源，服务器返回资源以及 `Last-Modified`/`ETag` 等缓存标识，同时可以配合强缓存头。
   Last-Modified: 表示资源最后修改的时间；

ETag: 表示资源的唯一标识符（通常是根据文件内容计算的哈希值）；

可以配合返回 Cache-Control 或 Expires 实现强缓存。

2. **后续请求**  
   浏览器向服务器发送条件请求，请求头中包含 `If-Modified-Since` 或 `If-None-Match`。  
   - 如果服务器判断资源未更改，则返回 304 状态码，不返回资源体。  
   - 如果资源已更改，则返回新的资源和更新后的缓存标识。
   If-Modified-Since: 对应上次响应中的 Last-Modified；

If-None-Match: 对应上次响应中的 ETag。

### 2.4 优点与缺点

**优点：**
- 保证资源最新：即使缓存未过期，服务器也能通过条件请求判断资源是否更新。  
- 节省带宽：304 响应体为空，传输的数据量非常小。

**缺点：**
- 需要发起网络请求，虽然数据量小但仍有一定延迟。  
- 服务器需要额外逻辑支持条件判断。

---

## 三、加载顺序与缓存的优化策略

在实际项目中，我们可以通过以下策略来优化加载性能：

1. **合理配置缓存响应头**  
   - 对于不经常更新的资源（如图片、静态文件），可以使用强缓存（设置长的 `max-age` 或合适的 `Expires`）。  
   - 对于经常更新但不希望用户频繁下载的资源（如 JavaScript、CSS），使用协商缓存，通过 ETag 或 Last-Modified 来判断资源是否更新。

2. **版本管理**  
   - 在资源 URL 中加入版本号（如 `app.v1.js`），当资源更新时改变 URL，从而强制浏览器重新加载资源。  

3. **CDN 加速**  
   - 将静态资源托管在 CDN 上，不仅能享受缓存机制，还能通过地理位置加速访问。

4. **压缩与合并**  
   - 对 CSS、JavaScript 进行压缩和合并，减少 HTTP 请求数量和资源体积，进一步提高加载速度。

---

## 四、实际示例

### 4.1 强缓存配置示例（服务器端配置）

以 Nginx 为例，配置静态资源的强缓存：

```nginx
location /static/ {
    expires 1d;  # 设置缓存时间为 1 天
    add_header Cache-Control "public";
}
```

### 4.2 协商缓存配置示例（服务器端配置）

同样以 Nginx 为例，配置 ETag 机制（通常默认开启）：

```nginx
location /api/ {
    etag on;
    if_modified_since exact;
}
```

在客户端，条件请求自动由浏览器发起，无需额外配置。

---

## 五、总结

HTTP 缓存机制通过强缓存和协商缓存两种方式，帮助我们大幅提升页面加载速度和用户体验。  
- **强缓存**：在缓存有效期内直接使用本地资源，不发起网络请求，但资源更新不及时。  
- **协商缓存**：在缓存过期后发起条件请求，通过 304 响应判断是否更新，保证了资源的实时性，同时减少数据传输量。

在实际开发中，合理利用这两种机制，结合版本管理、CDN 加速和资源压缩，可以有效降低服务器压力和用户等待时间，打造高性能的 Web 应用。