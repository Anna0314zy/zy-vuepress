---
title: 數組
date: 2019-01-06
tags:
- 面试题
- 算法
---


## 二分法

- 数组从大到小 按照顺序排列


```js
const arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];
const target = 7;
let left = 0;
let right = arr.length - 1;
let mid;
// left <= right;[左闭右闭] 区间
while (left <= right) {
    // mid = Math.floor((left + right) / 2);
    mid = left + ((right - left) >> 1) ; // 算法更优
    //  mid = left + ((right - left) >> 1)  等价于 mid = Math.floor((left + right) / 2);
    console.log(mid);
    if (arr[mid] === target) {
        console.log(`Found ${target} at index ${mid}`);
        break;
    } else if (arr[mid] < target) {
        left = mid + 1;
    } else {
        right = mid - 1;
    }
}

```
二分查找（Binary Search）是一种高效的查找算法，适用于在**有序数组**中查找特定元素。其核心思想是每次将查找范围缩小一半，从而快速定位目标元素。

---

### ⏱️ 时间复杂度分析

- **最坏情况时间复杂度：** O(log n)
  - 在最坏的情况下，算法需要进行 log₂(n) 次比较才能找到目标元素或确定其不存在。

- **平均情况时间复杂度：** O(log n)
  - 由于每次都将查找范围减半，平均情况下所需的比较次数也是对数级别。

- **最佳情况时间复杂度：** O(1)
  - 如果目标元素恰好位于数组的中间位置，算法只需一次比较即可找到。

---

### 📦 空间复杂度分析

- **迭代实现：**O(1
  -使用循环结构，不需要额外的空间

- **递归实现：**O(log n
  -由于递归调用的堆栈深度为 log₂(n)，因此空间复杂度为 O(log n)

---

## 删除数组元素
### 删除数组某一个元素
- 双指针技巧：使用快慢两个指针，快指针遍历数组，慢指针标记有效位置。

- 原地修改：将非目标值的元素前移，覆盖无效元素，空间复杂度 O(1)。

- 时间复杂度：O(n)，只需一次遍历。

```js
const nums = [0,1,2,3,0,4,2]
function removeElement(nums, val) {
    let slowIndex = 0;
    for (let fastIndex = 0; fastIndex < nums.length; fastIndex++) {
        if (nums[fastIndex] !== val) {
            nums[slowIndex++] = nums[fastIndex];
        }
    }
    return slowIndex;
}
function removeElement2(nums, val) {
    let slowIndex = 0,fastIndex = 0;
    while (fastIndex < nums.length) {
        if (nums[fastIndex] !== val) {
            nums[slowIndex++] = nums[fastIndex];
        }
        fastIndex++;
    }
    return slowIndex;
}
const newLength = removeElement2(nums, 2);
console.log(nums.slice(0, newLength)); // [0, 1, 3, 0, 4]

```

### 删除数组重复的元素 

有序数组删除重复的元素

```js
var removeDuplicates = function(nums) {
    if (nums.length === 0) return 0;
    let slow = 1;
    for (let fast = 1; fast < nums.length; fast++) {
        if (nums[fast] !== nums[fast - 1]) {
            nums[slow] = nums[fast];
            slow++;
        }
    }
    return slow;
};
```
## 比较含退格的字符串

```js
// 给定 s 和 t 两个字符串，当它们分别被输入到空白的文本编辑器后，如果两者相等，返回 true 。# 代表退格字符。

// 注意：如果对空文本输入退格字符，文本继续为空。

// s = "ab#c", t = "ad#c"

function backspaceCompare(s, t) {
    function process(str) {
        const stack = [];
        for (let i = 0; i < str.length; i++) {
            if (str[i] !== '#') {
                stack.push(str[i]);
            } else if (stack.length > 0) {
                stack.pop();
            }
        }
        return stack.join('');
    }

    return process(s) === process(t);
}




```
## 有序数组的平方

最大值一定在两边  用 2个指针 向中间移动

给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。

 

示例 1：

输入：nums = [-4,-1,0,3,10]
输出：[0,1,9,16,100]
解释：平方后，数组变为 [16,1,0,9,100]
排序后，数组变为 [0,1,9,16,100]
示例 2：

输入：nums = [-7,-3,2,3,11]
输出：[4,9,9,49,121]

```js
function sortedSquares(nums) {
    const n = nums.length;
    const result = new Array(n);
    let left = 0;
    let right = n - 1;
    let pos = n - 1;

    while (left <= right) {
        const leftVal = nums[left];
        const rightVal = nums[right];
        if (Math.abs(leftVal) > Math.abs(rightVal)) {
            result[pos] = leftVal * leftVal;
            left++;
        } else {
            result[pos] = rightVal * rightVal;
            right--;
        }
        pos--;
    }

    return result;
}

```
您提供的 `backspaceCompare` 函数通过模拟文本编辑器的退格操作，比较两个字符串在处理退格字符（`#`）后的最终结果是否相同。

---

### ⏱️ 时间复杂度

- **每个字符串的处理：** 函数 `process` 遍历输入字符串一次，对于每个字符，执行常数时间的操作（如 `push` 或 `pop`）。
- **总时间复杂度：** 设 `n` 和 `m` 分别为字符串 `s` 和 `t` 的长度，则总时间复杂度为 O(n + m)。

---

### 📦 空间复杂度

- **辅助空间：**函数 `process` 使用一个栈来存储处理后的字符，最坏情况下，栈的大小可能等于输入字符串的长度
- **总空间复杂度：**O(n + m)，用于存储两个栈的内容

---

### ✅ 总结

- **时间复杂度：**O(n + m
- **空间复杂度：**O(n + m
如果您希望进一步优化空间使用，可以考虑使用双指针从字符串末尾向前遍历，跳过应被退格的字符，从而在 O(1) 的空间复杂度下完成比较 

## 长度最小的子数组

给定一个含有 n 个正整数的数组和一个正整数 target 。

找出该数组中满足其总和大于等于 target 的长度最小的 子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。

 

示例 1：

输入：target = 7, nums = [2,3,1,2,4,3]
输出：2
解释：子数组 [4,3] 是该条件下的长度最小的子数组。
示例 2：

输入：target = 4, nums = [1,4,4]
输出：1
示例 3：

输入：target = 11, nums = [1,1,1,1,1,1,1,1]
输出：0·······

## 有效的字母异位词
给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的 字母异位词。

 

示例 1:

输入: s = "anagram", t = "nagaram"
输出: true
示例 2:

输入: s = "rat", t = "car"
输出: false

要判断字符串 `t` 是否是字符串 `s` 的字母异位词（Anagram），可以通过比较两个字符串中每个字符的出现次数是否一致来实现。

---

### ✅ 方法一：使用字符计数（哈希表）

这种方法通过统计每个字符串中字符的频率，然后比较两个频率表是否相同。


```javascript
function isAnagram(s, t) {
    if (s.length !== t.length) return false;

    const count = {};

    for (let char of s) {
        count[char] = (count[char] || 0) + 1;
    }

    for (let char of t) {
        if (!count[char]) return false;
        count[char]--;
    }

    return true;
}
```


**示例：**


```javascript
console.log(isAnagram("anagram", "nagaram")); // 输出: true
console.log(isAnagram("rat", "car"));         // 输出: false
```


**时间复杂度：** O(n)，其中 n 是字符串的长度。

**空间复杂度：** O(1)，因为哈希表最多包含 26 个英文字母的键。

---

### ✅ 方法二：排序比较

这种方法通过将两个字符串排序，然后比较排序后的结果是否相同。


```javascript
function isAnagram(s, t) {
    return s.split('').sort().join('') === t.split('').sort().join('');
}
```


**示例：**


```javascript
console.log(isAnagram("listen", "silent")); // 输出: true
console.log(isAnagram("hello", "bello"));   // 输出: false
```


**时间复杂度：** O(n log n)，主要是排序的开销。

**空间复杂度：** O(n)，用于存储排序后的字符串。

---

### ✅ 方法三：使用数组计数（适用于仅包含小写字母的情况）

如果字符串只包含小写英文字母，可以使用固定大小的数组来计数，提高性能。


```javascript
function isAnagram(s, t) {
    if (s.length !== t.length) return false;

    const count = new Array(26).fill(0);

    for (let i = 0; i < s.length; i++) {
        count[s.charCodeAt(i) - 97]++;
        count[t.charCodeAt(i) - 97]--;
    }

    return count.every(c => c === 0);
}
```


**示例：**


```javascript
console.log(isAnagram("abc", "bca")); // 输出: true
console.log(isAnagram("abc", "abd")); // 输出: false
```


**时间复杂度：** O(n)

**空间复杂度：** O(1)，因为数组大小固定为 26。

---

**总结：**

- 如果字符串长度较短，使用排序比较的方法简单易实现。
- 如果字符串较长或需要处理大量数据，使用字符计数的方法更高效。
- 如果确定字符串只包含小写英文字母，使用数组计数的方法性能最佳。

您可以根据具体情况选择合适的方法。 