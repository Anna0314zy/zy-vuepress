---
title: 微前端技术优化
tags:
  - 微前端
---


1. ✅ **预加载**
2. ✅ **资源共享**
3. ✅ **子应用缓存（KeepAlive）**
4. ✅ **丝滑转场（过渡动画）**
5. ✅ **完整 DEMO 示例**

---

## 📦 依赖安装

```bash
npm install micro-app
```

```ts
// main.ts (主应用入口)
import { createApp } from 'vue'
import App from './App.vue'
import microApp from '@micro-zoe/micro-app'

microApp.start() // 启动 micro-app

createApp(App).mount('#app')
```

---

## 1️⃣ 预加载子应用资源（提前加载子应用）

### ✅ 示例：预加载一个子应用

```ts
import microApp from '@micro-zoe/micro-app'

// 预加载：子应用在未来可能会被访问，先加载静态资源
microApp.preFetch([
  { name: 'sub-vue', url: 'http://localhost:7100/' },
  { name: 'sub-react', url: 'http://localhost:7200/' }
])
```

> 🔥 提前预热，加快用户首次访问速度！

---

## 2️⃣ 子应用资源共享（减少重复加载）


### ✅ 主应用 HTML 加载 Vue，设置共享
- 方式一、globalAssets
globalAssets用于设置全局共享资源，它和预加载的思路相同，在浏览器空闲时加载资源并放入缓存。

当子应用加载相同地址的js或css资源时，会直接从缓存中提取数据，从而提升渲染速度。

使用方式

```js

// index.js
import microApp from '@micro-zoe/micro-app'

microApp.start({
  globalAssets: {
    js: ['js地址1', 'https://cdn.jsdelivr.net/npm/vue@2.7.14/dist/vue.min.js', ...], // js地址, // js地址
    css: ['css地址1', 'css地址2', ...], // css地址
  }
})

// 子应用

export default defineConfig({
  build: {
    rollupOptions: {
      external: ['vue']
    }
  }
})
```
- 方式二、global 属性

在link、script设置global属性会将文件提取为公共文件，共享给其它应用。

设置global属性后文件第一次加载会放入公共缓存，其它子应用加载相同的资源时直接从缓存中读取内容，从而提升渲染速度。

使用方式

```js

<link rel="stylesheet" href="xx.css" global>
<script src="xx.js" global></script>

```

---

## 3️⃣ 子应用缓存（KeepAlive）

### ✅ 示例：缓存子应用，切换路由不销毁

```vue
<template>
  <div>
    <micro-app
      name="sub-vue"
      url="http://localhost:7100/"
      :keep-alive="true"
      baseroute="/sub-vue"
    />
  </div>
</template>
```

> 🧠 keep-alive = true 时，子应用 DOM 保留不销毁，提高切换速度，适合 Tab 应用场景。

---

## 4️⃣ 丝滑转场动画

### ✅ 加 CSS 动画实现入场/出场效果

```vue
<template>
  <transition name="fade">
    <micro-app
      v-if="showApp"
      name="sub-vue"
      url="http://localhost:7100/"
      :keep-alive="true"
      baseroute="/sub-vue"
    />
  </transition>
</template>

<script setup>
import { ref } from 'vue'
const showApp = ref(true)
</script>

<style>
.fade-enter-active, .fade-leave-active {
  transition: opacity 0.3s ease;
}
.fade-enter-from, .fade-leave-to {
  opacity: 0;
}
</style>
```

> 🚀 动画结合 keep-alive 实现更丝滑的用户体验。

---

## 5️⃣ 完整主应用 DEMO（整合预加载 + 缓存 + 动画）

```vue
<!-- App.vue -->
<template>
  <div>
    <button @click="toggleApp">切换子应用</button>
    <transition name="fade">
      <micro-app
        v-if="show"
        name="sub-vue"
        url="http://localhost:7100/"
        baseroute="/sub-vue"
        :keep-alive="true"
      />
    </transition>
  </div>
</template>

<script setup>
import { ref, onMounted } from 'vue'
import microApp from '@micro-zoe/micro-app'

const show = ref(true)

function toggleApp() {
  show.value = !show.value
}

onMounted(() => {
  microApp.preFetch([
    { name: 'sub-vue', url: 'http://localhost:7100/' }
  ])
})
</script>

<style>
.fade-enter-active, .fade-leave-active {
  transition: opacity 0.3s ease;
}
.fade-enter-from, .fade-leave-to {
  opacity: 0;
}
</style>
```

---

## ✅ 最佳实践建议

| 场景        | 优化建议                                   |
| --------- | -------------------------------------- |
| 首次访问慢     | 使用 `preFetch` 提前加载资源                   |
| 资源体积大     | 主子应用共享 CDN 依赖                          |
| 子应用频繁切换   | 开启 `keep-alive` 保持缓存                   |
| 页面切换不流畅   | `transition` + `keep-alive` 加动画        |
| 子应用生命周期控制 | 使用 `microApp.start({ lifeCycles })` 配置 |

---



---

## ✅ micro-app 进阶优化点汇总

| 优化点              | 说明                    |
| ---------------- | --------------------- |
| ✅ 动态权限加载         | 子应用按权限控制是否加载          |
| ✅ 沙箱性能优化         | 关闭非必要隔离项提高运行效率        |
| ✅ 全局状态通信         | 主子应用之间共享状态、响应式通信      |
| ✅ 资源缓存策略         | 离线缓存，或本地存储子应用静态资源     |
| ✅ 子应用懒加载         | 只在访问时加载子应用，节省初始化资源    |
| ✅ 子应用降级机制        | 子应用加载失败时使用降级 HTML 或提示 |
| ✅ 子应用 Loading 占位 | 加载中显示动画，提高用户体验        |
| ✅ 统一错误处理         | 主应用拦截子应用的 JS/加载错误统一上报 |
| ✅ 子应用卸载清理        | 离开页面时清理全局事件、定时器等资源    |
| ✅ 子应用访问控制        | 禁止某些角色访问子应用，增强安全性     |

---

## 🔍 详细示例与建议

### 1️⃣ 动态权限加载子应用

```ts
const apps = [
  {
    name: 'admin-app',
    url: 'http://localhost:7100/',
    roles: ['admin']
  },
  {
    name: 'user-app',
    url: 'http://localhost:7200/',
    roles: ['user', 'admin']
  }
]

const userRole = 'user'

const visibleApps = apps.filter(app => app.roles.includes(userRole))
```

---

### 2️⃣ 优化沙箱配置

如果你不需要严格的隔离（比如只加载静态页面），可以关闭部分隔离：

```ts
microApp.start({
  sandbox: {
    strictStyleIsolation: false, // 少用 ShadowDOM 提升性能
    disableFakeBody: true        // 禁用代理 body，减少内存消耗
  }
})
```

---

### 3️⃣ 全局状态共享通信（主子应用）

```ts
// 主应用
microApp.setGlobalData({ token: 'xxx' })

// 子应用监听数据变化
window.microApp?.addDataListener((data) => {
  console.log('主应用传来数据:', data)
})
```

---

### 4️⃣ 子应用懒加载（按需加载）

```vue
<template>
  <micro-app
    v-if="hasPermission"
    name="sub-vue"
    url="http://localhost:7100/"
    baseroute="/sub-vue"
  />
</template>
```

---

### 5️⃣ 子应用加载失败降级机制

```vue
<template>
  <micro-app
    name="sub-vue"
    url="http://localhost:7100/"
    @error="handleError"
  />
</template>

<script setup>
function handleError(e) {
  console.warn('子应用加载失败', e)
  // 提示用户 或 显示本地 HTML 组件
}
</script>
```

---

### 6️⃣ 子应用 Loading 提示

```vue
<template>
  <div>
    <div v-if="loading">子应用加载中...</div>
    <micro-app
      name="sub-vue"
      url="http://localhost:7100/"
      @mounted="loading = false"
      @error="loading = false"
    />
  </div>
</template>

<script setup>
import { ref } from 'vue'
const loading = ref(true)
</script>
```

---

### 7️⃣ 子应用清理副作用（内存泄漏预防）

子应用中：

```ts
// 监听主应用卸载事件
window.addEventListener('unmount', () => {
  clearInterval(timer)
  window.removeEventListener('scroll', handleScroll)
})
```

---

## 🧠 补充建议

* ✅ 子应用可配合 Vite + import.meta.env 实现环境切换
* ✅ 使用 CDN 加速子应用静态资源加载
* ✅ Nginx 支持主子应用分路径部署（如 `/main/`, `/sub-vue/`）
* ✅ 推荐主子应用使用统一的 UI 库版本（避免样式冲突）

---

