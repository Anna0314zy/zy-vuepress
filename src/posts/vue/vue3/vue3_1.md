---
title: vue3 computed 和 watch
tags:
  - vue3
---



## **🔥 Vue 3 计算属性 vs. `watch`，为什么计算属性不能有副作用？**  

在 Vue 3 中，**计算属性（computed）** 和 **`watch` 监听器** 都用于**响应数据的变化**，但它们的用途和实现方式不同：  

| **对比项**  | **计算属性 (`computed`)** | **监听器 (`watch`)** |
|------------|-----------------|-----------------|
| **作用**   | 依赖变化时 **返回计算结果** | 依赖变化时 **执行副作用** |
| **是否缓存** | ✅ **缓存结果**，只有依赖变化时才重新计算 | ❌ **不会缓存**，每次依赖变化都会执行 |
| **是否有副作用** | ❌ **不能有副作用** | ✅ **可以有副作用** |
| **适用场景** | 计算派生数据（如 `fullName`） | 处理异步请求、手动执行逻辑 |

---

## **🚀 计算属性为什么不能有副作用？**
### **✅ 计算属性的本质**
计算属性 **本质上是一个 `watchEffect`**，**但带有缓存**，Vue 3 在内部通过 `effect()` 处理 **依赖收集和响应更新**。  

计算属性的特点：  
1. **缓存结果**：只有依赖发生变化时才会重新计算。  
2. **依赖追踪**：Vue 追踪它内部用到的响应式数据。  
3. **同步返回值**：计算属性的值可以直接用于模板或代码逻辑中。  

### **❌ 如果计算属性有副作用，会导致意外的行为**
```typescript
import { ref, computed } from "vue";

const count = ref(0);
const doubleCount = computed(() => {
  console.log("计算属性执行副作用！"); // ❌ 不推荐！
  return count.value * 2;
});

count.value++; // 触发 doubleCount 重新计算
```

📌 **问题：**  
- 每次 `count.value` 变化，`computed` 都会执行副作用（`console.log`）。  
- 由于 **computed 可能会被多次访问**，可能导致**副作用被多次执行**。  
- **Vue 会缓存计算结果**，但如果 `computed` 访问了 **不相关的数据**，Vue 可能会错误地优化它的更新。  

**🚫 计算属性的设计目标是派生数据，而不是执行额外逻辑！**

---

## **🚀 为什么 `watch` 可以有副作用？**
### **✅ `watch` 本质上是一个独立的副作用 (`effect`)**
`watch` 的核心作用：  
- **观察数据变化**，并执行**回调函数**（可以有副作用）。  
- **不缓存结果**，每次依赖变化时都会执行回调。  
- **适用于异步操作、手动执行逻辑（如 API 请求）**。

```typescript
import { ref, watch } from "vue";

const count = ref(0);

watch(count, (newValue, oldValue) => {
  console.log(`count 变了: ${oldValue} -> ${newValue}`);
  // ✅ 副作用：可以执行 API 请求、修改 DOM 等
});
```

📌 **为什么 `watch` 可以有副作用？**  
1. **不会缓存**，每次依赖变化都会执行回调，所以副作用不会被跳过。  
2. **明确的触发机制**，只有当监听的数据发生变化时才会执行回调，副作用的执行逻辑可控。  
3. **副作用只发生一次**，不像 `computed` 可能会被多次访问。  

---

## **🚀 计算属性 vs. `watch` 实际应用场景**
| **场景** | **使用 `computed`** | **使用 `watch`** |
|---------|----------------|---------------|
| **模板中的派生数据** | ✅ `computed` 最适合 | ❌ 不适合 |
| **监听数据变化并触发异步操作** | ❌ 不适合 | ✅ `watch` 最适合 |
| **缓存计算结果** | ✅ `computed` 自动缓存 | ❌ `watch` 不缓存 |
| **执行副作用（如 API 请求）** | ❌ 不能有副作用 | ✅ 适用于副作用 |

### **✅ 示例 1：适合 `computed` 的场景**
```typescript
const firstName = ref("John");
const lastName = ref("Doe");

const fullName = computed(() => {
  return `${firstName.value} ${lastName.value}`;
});
```
📌 **`fullName` 是 `firstName` 和 `lastName` 的派生数据，应该使用 `computed`**。

---

### **✅ 示例 2：适合 `watch` 的场景**
```typescript
watch(fullName, (newVal) => {
  console.log("用户全名变了！", newVal);
  // ✅ 可以发送 API 请求、写日志等
});
```
📌 **这里 `watch` 用于监听 `fullName` 变化，并触发副作用**。

---

## **🎯 总结**
| **特性** | **计算属性（computed）** | **监听器（watch）** |
|--------|----------------|----------------|
| **是否缓存** | ✅ **缓存结果** | ❌ **不缓存** |
| **是否有副作用** | ❌ 不能有副作用 | ✅ 可以有副作用 |
| **适用场景** | 计算派生数据，如 `fullName` | 监听数据变化，触发 API 调用等 |
| **执行时机** | **在模板/代码中被访问时执行** | **数据变化时执行** |
| **Vue 内部实现** | **基于 `effect`，带缓存** | **基于 `effect`，无缓存** |

### **🔥 为什么计算属性不能有副作用？**
1. **计算属性会被缓存**，可能导致副作用**不会每次都执行**。
2. **计算属性会被模板或代码访问多次**，可能导致**副作用执行多次**，造成**意外行为**。
3. **Vue 内部优化** 可能会跳过不必要的计算，导致副作用**不稳定**。

### **🔥 为什么 `watch` 可以有副作用？**
1. **每次数据变化时都会执行**，不会缓存，所以副作用可以安全执行。
2. **专门设计用于副作用**，如 API 请求、日志记录等。
3. **避免了 `computed` 副作用的潜在问题**，保证逻辑清晰。

---

## **🔥 总结建议**
- **需要计算数据时，使用 `computed`**（不能有副作用）。  
- **需要监听数据并触发副作用时，使用 `watch`**（可以有副作用）。  
- **在 `computed` 里不要写 `console.log`、API 请求等副作用代码，否则可能会有不可预期的行为。**